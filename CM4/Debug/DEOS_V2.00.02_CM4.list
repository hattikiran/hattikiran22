
DEOS_V2.00.02_CM4.elf:     file format elf32-littlearm

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .isr_vector   00000298  08100000  08100000  00010000  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  1 .text         00001320  081002a0  081002a0  000102a0  2**4
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .rodata       00000010  081015c0  081015c0  000115c0  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  3 .init_array   00000004  081015d0  081015d0  000115d0  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  4 .fini_array   00000004  081015d4  081015d4  000115d4  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  5 .data         00000010  10000000  081015d8  00020000  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  6 .bss          00000218  10000010  081015e8  00020010  2**2
                  ALLOC
  7 ._user_heap_stack 00000600  10000228  081015e8  00020228  2**0
                  ALLOC
  8 .ARM.attributes 00000030  00000000  00000000  00020010  2**0
                  CONTENTS, READONLY
  9 .debug_info   000094c9  00000000  00000000  00020040  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 10 .debug_abbrev 00001bbd  00000000  00000000  00029509  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 11 .debug_aranges 000007e8  00000000  00000000  0002b0c8  2**3
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 12 .debug_ranges 00000698  00000000  00000000  0002b8b0  2**3
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 13 .debug_macro  0003db55  00000000  00000000  0002bf48  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 14 .debug_line   0000a271  00000000  00000000  00069a9d  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 15 .debug_str    00191d7e  00000000  00000000  00073d0e  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 16 .comment      00000050  00000000  00000000  00205a8c  2**0
                  CONTENTS, READONLY
 17 .debug_frame  00001afc  00000000  00000000  00205adc  2**2
                  CONTENTS, READONLY, DEBUGGING, OCTETS

Disassembly of section .text:

081002a0 <__do_global_dtors_aux>:
 81002a0:	b510      	push	{r4, lr}
 81002a2:	4c05      	ldr	r4, [pc, #20]	; (81002b8 <__do_global_dtors_aux+0x18>)
 81002a4:	7823      	ldrb	r3, [r4, #0]
 81002a6:	b933      	cbnz	r3, 81002b6 <__do_global_dtors_aux+0x16>
 81002a8:	4b04      	ldr	r3, [pc, #16]	; (81002bc <__do_global_dtors_aux+0x1c>)
 81002aa:	b113      	cbz	r3, 81002b2 <__do_global_dtors_aux+0x12>
 81002ac:	4804      	ldr	r0, [pc, #16]	; (81002c0 <__do_global_dtors_aux+0x20>)
 81002ae:	f3af 8000 	nop.w
 81002b2:	2301      	movs	r3, #1
 81002b4:	7023      	strb	r3, [r4, #0]
 81002b6:	bd10      	pop	{r4, pc}
 81002b8:	10000010 	.word	0x10000010
 81002bc:	00000000 	.word	0x00000000
 81002c0:	081015a8 	.word	0x081015a8

081002c4 <frame_dummy>:
 81002c4:	b508      	push	{r3, lr}
 81002c6:	4b03      	ldr	r3, [pc, #12]	; (81002d4 <frame_dummy+0x10>)
 81002c8:	b11b      	cbz	r3, 81002d2 <frame_dummy+0xe>
 81002ca:	4903      	ldr	r1, [pc, #12]	; (81002d8 <frame_dummy+0x14>)
 81002cc:	4803      	ldr	r0, [pc, #12]	; (81002dc <frame_dummy+0x18>)
 81002ce:	f3af 8000 	nop.w
 81002d2:	bd08      	pop	{r3, pc}
 81002d4:	00000000 	.word	0x00000000
 81002d8:	10000014 	.word	0x10000014
 81002dc:	081015a8 	.word	0x081015a8

081002e0 <_tx_initialize_low_level>:
    .thumb_func
_tx_initialize_low_level:
@
@    /* Disable interrupts during ThreadX initialization.  */
@
    CPSID   i
 81002e0:	b672      	cpsid	i
    STR     r1, [r0]                                @ Setup first unused memory pointer
#endif
@
@    /* Setup Vector Table Offset Register.  */
@
    MOV     r0, #0xE000E000                         @ Build address of NVIC registers
 81002e2:	f04f 20e0 	mov.w	r0, #3758153728	; 0xe000e000
    LDR     r1, =g_pfnVectors                           @ Pickup address of vector table
 81002e6:	491a      	ldr	r1, [pc, #104]	; (8100350 <__tx_DBGHandler+0x6>)
    STR     r1, [r0, #0xD08]                        @ Set vector table address
 81002e8:	f8c0 1d08 	str.w	r1, [r0, #3336]	; 0xd08
@
@    /* Set system stack pointer from vector value.  */
@
    LDR     r0, =_tx_thread_system_stack_ptr        @ Build address of system stack pointer
 81002ec:	4819      	ldr	r0, [pc, #100]	; (8100354 <__tx_DBGHandler+0xa>)
    LDR     r1, =g_pfnVectors                           @ Pickup address of vector table
 81002ee:	4918      	ldr	r1, [pc, #96]	; (8100350 <__tx_DBGHandler+0x6>)
    LDR     r1, [r1]                                @ Pickup reset stack pointer
 81002f0:	6809      	ldr	r1, [r1, #0]
    STR     r1, [r0]                                @ Save system stack pointer
 81002f2:	6001      	str	r1, [r0, #0]
@
@    /* Enable the cycle count register.  */
@
    LDR     r0, =0xE0001000                         @ Build address of DWT register
 81002f4:	4818      	ldr	r0, [pc, #96]	; (8100358 <__tx_DBGHandler+0xe>)
    LDR     r1, [r0]                                @ Pickup the current value
 81002f6:	6801      	ldr	r1, [r0, #0]
    ORR     r1, r1, #1                              @ Set the CYCCNTENA bit
 81002f8:	f041 0101 	orr.w	r1, r1, #1
    STR     r1, [r0]                                @ Enable the cycle count register
 81002fc:	6001      	str	r1, [r0, #0]
@
@    /* Configure SysTick for 100Hz clock, or 16384 cycles if no reference.  */
@
    MOV     r0, #0xE000E000                         @ Build address of NVIC registers
 81002fe:	f04f 20e0 	mov.w	r0, #3758153728	; 0xe000e000
    LDR     r1, =SYSTICK_CYCLES
 8100302:	f64e 215f 	movw	r1, #59999	; 0xea5f
    STR     r1, [r0, #0x14]                         @ Setup SysTick Reload Value
 8100306:	6141      	str	r1, [r0, #20]
    MOV     r1, #0x7                                @ Build SysTick Control Enable Value
 8100308:	f04f 0107 	mov.w	r1, #7
    STR     r1, [r0, #0x10]                         @ Setup SysTick Control
 810030c:	6101      	str	r1, [r0, #16]
@
@    /* Configure handler priorities.  */
@
    LDR     r1, =0x00000000                         @ Rsrv, UsgF, BusF, MemM
 810030e:	f04f 0100 	mov.w	r1, #0
    STR     r1, [r0, #0xD18]                        @ Setup System Handlers 4-7 Priority Registers
 8100312:	f8c0 1d18 	str.w	r1, [r0, #3352]	; 0xd18

    LDR     r1, =0xFF000000                         @ SVCl, Rsrv, Rsrv, Rsrv
 8100316:	f04f 417f 	mov.w	r1, #4278190080	; 0xff000000
    STR     r1, [r0, #0xD1C]                        @ Setup System Handlers 8-11 Priority Registers
 810031a:	f8c0 1d1c 	str.w	r1, [r0, #3356]	; 0xd1c
                                                    @ Note: SVC must be lowest priority, which is 0xFF

    LDR     r1, =0x40FF0000                         @ SysT, PnSV, Rsrv, DbgM
 810031e:	490f      	ldr	r1, [pc, #60]	; (810035c <__tx_DBGHandler+0x12>)
    STR     r1, [r0, #0xD20]                        @ Setup System Handlers 12-15 Priority Registers
 8100320:	f8c0 1d20 	str.w	r1, [r0, #3360]	; 0xd20
                                                    @ Note: PnSV must be lowest priority, which is 0xFF
@
@    /* Return to caller.  */
@
    BX      lr
 8100324:	4770      	bx	lr

08100326 <__tx_BadHandler>:
@/* Define shells for each of the unused vectors.  */
@
    .global  __tx_BadHandler
    .thumb_func
__tx_BadHandler:
    B       __tx_BadHandler
 8100326:	f7ff bffe 	b.w	8100326 <__tx_BadHandler>

0810032a <__tx_HardfaultHandler>:
@ /* added to catch the hardfault */

    .global  __tx_HardfaultHandler
    .thumb_func
__tx_HardfaultHandler:
    B       __tx_HardfaultHandler
 810032a:	f7ff bffe 	b.w	810032a <__tx_HardfaultHandler>

0810032e <__tx_SVCallHandler>:
@ /* added to catch the SVC */

    .global  __tx_SVCallHandler
    .thumb_func
__tx_SVCallHandler:
    B       __tx_SVCallHandler
 810032e:	f7ff bffe 	b.w	810032e <__tx_SVCallHandler>

08100332 <__tx_IntHandler>:
    .global  __tx_IntHandler
    .thumb_func
__tx_IntHandler:
@ VOID InterruptHandler (VOID)
@ {
    PUSH    {r0, lr}
 8100332:	b501      	push	{r0, lr}
@    /* BL <your C Function>.... */

#ifdef TX_EXECUTION_PROFILE_ENABLE
    BL      _tx_execution_isr_exit              @ Call the ISR exit function
#endif
    POP     {r0, lr}
 8100334:	e8bd 4001 	ldmia.w	sp!, {r0, lr}
    BX      LR
 8100338:	4770      	bx	lr

0810033a <SysTick_Handler>:
    .thumb_func
SysTick_Handler:
@ VOID TimerInterruptHandler (VOID)
@ {
@
    PUSH    {r0, lr}
 810033a:	b501      	push	{r0, lr}
#ifdef TX_EXECUTION_PROFILE_ENABLE
    BL      _tx_execution_isr_enter             @ Call the ISR enter function
#endif
    BL      _tx_timer_interrupt
 810033c:	f000 f870 	bl	8100420 <_tx_timer_interrupt>
#ifdef TX_EXECUTION_PROFILE_ENABLE
    BL      _tx_execution_isr_exit              @ Call the ISR exit function
#endif
    POP     {r0, lr}
 8100340:	e8bd 4001 	ldmia.w	sp!, {r0, lr}
    BX      LR
 8100344:	4770      	bx	lr

08100346 <__tx_NMIHandler>:

@ /* NMI, DBG handlers */
    .global  __tx_NMIHandler
    .thumb_func
__tx_NMIHandler:
    B       __tx_NMIHandler
 8100346:	f7ff bffe 	b.w	8100346 <__tx_NMIHandler>

0810034a <__tx_DBGHandler>:

    .global  __tx_DBGHandler
    .thumb_func
__tx_DBGHandler:
    B       __tx_DBGHandler
 810034a:	f7ff bffe 	b.w	810034a <__tx_DBGHandler>
 810034e:	0000      	.short	0x0000
    LDR     r1, =g_pfnVectors                           @ Pickup address of vector table
 8100350:	08100000 	.word	0x08100000
    LDR     r0, =_tx_thread_system_stack_ptr        @ Build address of system stack pointer
 8100354:	1000002c 	.word	0x1000002c
    LDR     r0, =0xE0001000                         @ Build address of DWT register
 8100358:	e0001000 	.word	0xe0001000
    LDR     r1, =0x40FF0000                         @ SysT, PnSV, Rsrv, DbgM
 810035c:	40ff0000 	.word	0x40ff0000

08100360 <_tx_thread_schedule>:
       from the first schedule request. Subsequent scheduling occurs
       from the PendSV handling routine below. */

    /* Clear the preempt-disable flag to enable rescheduling after initialization on Cortex-M targets.  */

    MOV     r0, #0                                  // Build value for TX_FALSE
 8100360:	f04f 0000 	mov.w	r0, #0
    LDR     r2, =_tx_thread_preempt_disable         // Build address of preempt disable flag
 8100364:	4a2a      	ldr	r2, [pc, #168]	; (8100410 <tx_thread_fpu_disable+0x2>)
    STR     r0, [r2, #0]                            // Clear preempt disable flag
 8100366:	6010      	str	r0, [r2, #0]

    /* Clear CONTROL.FPCA bit so VFP registers aren't unnecessarily stacked.  */

#ifdef __ARM_FP
    MRS     r0, CONTROL                             // Pickup current CONTROL register
 8100368:	f3ef 8014 	mrs	r0, CONTROL
    BIC     r0, r0, #4                              // Clear the FPCA bit
 810036c:	f020 0004 	bic.w	r0, r0, #4
    MSR     CONTROL, r0                             // Setup new CONTROL register
 8100370:	f380 8814 	msr	CONTROL, r0
#endif

    /* Enable interrupts */
    CPSIE   i
 8100374:	b662      	cpsie	i

    /* Enter the scheduler for the first time.  */

    MOV     r0, #0x10000000                         // Load PENDSVSET bit
 8100376:	f04f 5080 	mov.w	r0, #268435456	; 0x10000000
    MOV     r1, #0xE000E000                         // Load NVIC base
 810037a:	f04f 21e0 	mov.w	r1, #3758153728	; 0xe000e000
    STR     r0, [r1, #0xD04]                        // Set PENDSVBIT in ICSR
 810037e:	f8c1 0d04 	str.w	r0, [r1, #3332]	; 0xd04
    DSB                                             // Complete all memory accesses
 8100382:	f3bf 8f4f 	dsb	sy
    ISB                                             // Flush pipeline
 8100386:	f3bf 8f6f 	isb	sy

0810038a <__tx_wait_here>:

    /* Wait here for the PendSV to take place.  */

__tx_wait_here:
    B       __tx_wait_here                          // Wait for the PendSV to happen
 810038a:	e7fe      	b.n	810038a <__tx_wait_here>

0810038c <PendSV_Handler>:
#else
    CPSIE   i                                       // Enable interrupts
#endif  /* TX_PORT_USE_BASEPRI */
#endif  /* EXECUTION PROFILE */

    LDR     r0, =_tx_thread_current_ptr             // Build current thread pointer address
 810038c:	4821      	ldr	r0, [pc, #132]	; (8100414 <tx_thread_fpu_disable+0x6>)
    LDR     r2, =_tx_thread_execute_ptr             // Build execute thread pointer address
 810038e:	4a22      	ldr	r2, [pc, #136]	; (8100418 <tx_thread_fpu_disable+0xa>)
    MOV     r3, #0                                  // Build NULL value
 8100390:	f04f 0300 	mov.w	r3, #0
    LDR     r1, [r0]                                // Pickup current thread pointer
 8100394:	6801      	ldr	r1, [r0, #0]

    /* Determine if there is a current thread to finish preserving.  */

    CBZ     r1, __tx_ts_new                         // If NULL, skip preservation
 8100396:	b191      	cbz	r1, 81003be <__tx_ts_new>

    /* Recover PSP and preserve current thread context.  */

    STR     r3, [r0]                                // Set _tx_thread_current_ptr to NULL
 8100398:	6003      	str	r3, [r0, #0]
    MRS     r12, PSP                                // Pickup PSP pointer (thread's stack pointer)
 810039a:	f3ef 8c09 	mrs	ip, PSP
    STMDB   r12!, {r4-r11}                          // Save its remaining registers
 810039e:	e92c 0ff0 	stmdb	ip!, {r4, r5, r6, r7, r8, r9, sl, fp}
#ifdef __ARM_FP
    TST     LR, #0x10                               // Determine if the VFP extended frame is present
 81003a2:	f01e 0f10 	tst.w	lr, #16
    BNE     _skip_vfp_save
 81003a6:	d101      	bne.n	81003ac <_skip_vfp_save>
    VSTMDB  r12!,{s16-s31}                          // Yes, save additional VFP registers
 81003a8:	ed2c 8a10 	vstmdb	ip!, {s16-s31}

081003ac <_skip_vfp_save>:
_skip_vfp_save:
#endif
    LDR     r4, =_tx_timer_time_slice               // Build address of time-slice variable
 81003ac:	4c1b      	ldr	r4, [pc, #108]	; (810041c <tx_thread_fpu_disable+0xe>)
    STMDB   r12!, {LR}                              // Save LR on the stack
 81003ae:	f84c ed04 	str.w	lr, [ip, #-4]!

    /* Determine if time-slice is active. If it isn't, skip time handling processing.  */

    LDR     r5, [r4]                                // Pickup current time-slice
 81003b2:	6825      	ldr	r5, [r4, #0]
    STR     r12, [r1, #8]                           // Save the thread stack pointer
 81003b4:	f8c1 c008 	str.w	ip, [r1, #8]
    CBZ     r5, __tx_ts_new                         // If not active, skip processing
 81003b8:	b10d      	cbz	r5, 81003be <__tx_ts_new>

    /* Time-slice is active, save the current thread's time-slice and clear the global time-slice variable.  */

    STR     r5, [r1, #24]                           // Save current time-slice
 81003ba:	618d      	str	r5, [r1, #24]

    /* Clear the global time-slice.  */

    STR     r3, [r4]                                // Clear time-slice
 81003bc:	6023      	str	r3, [r4, #0]

081003be <__tx_ts_new>:

#ifdef TX_PORT_USE_BASEPRI
    LDR     r1, =TX_PORT_BASEPRI                    // Mask interrupt priorities =< TX_PORT_BASEPRI
    MSR     BASEPRI, r1
#else
    CPSID   i                                       // Disable interrupts
 81003be:	b672      	cpsid	i
#endif
    LDR     r1, [r2]                                // Is there another thread ready to execute?
 81003c0:	6811      	ldr	r1, [r2, #0]
    CBZ     r1, __tx_ts_wait                        // No, skip to the wait processing
 81003c2:	b1b1      	cbz	r1, 81003f2 <__tx_ts_wait>

    /* Yes, another thread is ready for else, make the current thread the new thread.  */

    STR     r1, [r0]                                // Setup the current thread pointer to the new thread
 81003c4:	6001      	str	r1, [r0, #0]
#ifdef TX_PORT_USE_BASEPRI
    MOV     r4, #0                                  // Disable BASEPRI masking (enable interrupts)
    MSR     BASEPRI, r4
#else
    CPSIE   i                                       // Enable interrupts
 81003c6:	b662      	cpsie	i

081003c8 <__tx_ts_restore>:
#endif

    /* Increment the thread run count.  */

__tx_ts_restore:
    LDR     r7, [r1, #4]                            // Pickup the current thread run count
 81003c8:	684f      	ldr	r7, [r1, #4]
    LDR     r4, =_tx_timer_time_slice               // Build address of time-slice variable
 81003ca:	4c14      	ldr	r4, [pc, #80]	; (810041c <tx_thread_fpu_disable+0xe>)
    LDR     r5, [r1, #24]                           // Pickup thread's current time-slice
 81003cc:	698d      	ldr	r5, [r1, #24]
    ADD     r7, r7, #1                              // Increment the thread run count
 81003ce:	f107 0701 	add.w	r7, r7, #1
    STR     r7, [r1, #4]                            // Store the new run count
 81003d2:	604f      	str	r7, [r1, #4]

    /* Setup global time-slice with thread's current time-slice.  */

    STR     r5, [r4]                                // Setup global time-slice
 81003d4:	6025      	str	r5, [r4, #0]
    POP     {r0, r1}                                // Recover r0 and r1
#endif

    /* Restore the thread context and PSP.  */

    LDR     r12, [r1, #8]                           // Pickup thread's stack pointer
 81003d6:	f8d1 c008 	ldr.w	ip, [r1, #8]
    LDMIA   r12!, {LR}                              // Pickup LR
 81003da:	f85c eb04 	ldr.w	lr, [ip], #4
#ifdef __ARM_FP
    TST     LR, #0x10                               // Determine if the VFP extended frame is present
 81003de:	f01e 0f10 	tst.w	lr, #16
    BNE     _skip_vfp_restore                       // If not, skip VFP restore
 81003e2:	d101      	bne.n	81003e8 <_skip_vfp_restore>
    VLDMIA  r12!, {s16-s31}                         // Yes, restore additional VFP registers
 81003e4:	ecbc 8a10 	vldmia	ip!, {s16-s31}

081003e8 <_skip_vfp_restore>:
_skip_vfp_restore:
#endif
    LDMIA   r12!, {r4-r11}                          // Recover thread's registers
 81003e8:	e8bc 0ff0 	ldmia.w	ip!, {r4, r5, r6, r7, r8, r9, sl, fp}
    MSR     PSP, r12                                // Setup the thread's stack pointer
 81003ec:	f38c 8809 	msr	PSP, ip

    /* Return to thread.  */

    BX      lr                                      // Return to thread!
 81003f0:	4770      	bx	lr

081003f2 <__tx_ts_wait>:
__tx_ts_wait:
#ifdef TX_PORT_USE_BASEPRI
    LDR     r1, =TX_PORT_BASEPRI                    // Mask interrupt priorities =< TX_PORT_BASEPRI
    MSR     BASEPRI, r1
#else
    CPSID   i                                       // Disable interrupts
 81003f2:	b672      	cpsid	i
#endif
    LDR     r1, [r2]                                // Pickup the next thread to execute pointer
 81003f4:	6811      	ldr	r1, [r2, #0]
    STR     r1, [r0]                                // Store it in the current pointer
 81003f6:	6001      	str	r1, [r0, #0]
    CBNZ    r1, __tx_ts_ready                       // If non-NULL, a new thread is ready!
 81003f8:	b909      	cbnz	r1, 81003fe <__tx_ts_ready>

#ifdef TX_PORT_USE_BASEPRI
    MOV     r4, #0                                  // Disable BASEPRI masking (enable interrupts)
    MSR     BASEPRI, r4
#else
    CPSIE   i                                       // Enable interrupts
 81003fa:	b662      	cpsie	i
#endif
    B       __tx_ts_wait                            // Loop to continue waiting
 81003fc:	e7f9      	b.n	81003f2 <__tx_ts_wait>

081003fe <__tx_ts_ready>:

    /* At this point, we have a new thread ready to go. Clear any newly pended PendSV - since we are
       already in the handler!  */

__tx_ts_ready:
    MOV     r7, #0x08000000                         // Build clear PendSV value
 81003fe:	f04f 6700 	mov.w	r7, #134217728	; 0x8000000
    MOV     r8, #0xE000E000                         // Build base NVIC address
 8100402:	f04f 28e0 	mov.w	r8, #3758153728	; 0xe000e000
    STR     r7, [r8, #0xD04]                        // Clear any PendSV
 8100406:	f8c8 7d04 	str.w	r7, [r8, #3332]	; 0xd04
    /* Re-enable interrupts and restore new thread.  */
#ifdef TX_PORT_USE_BASEPRI
    MOV     r4, #0                                  // Disable BASEPRI masking (enable interrupts)
    MSR     BASEPRI, r4
#else
    CPSIE   i                                       // Enable interrupts
 810040a:	b662      	cpsie	i
#endif
    B       __tx_ts_restore                         // Restore the thread
 810040c:	e7dc      	b.n	81003c8 <__tx_ts_restore>

0810040e <tx_thread_fpu_disable>:
tx_thread_fpu_disable:

    /* Automatic VPF logic is supported, this function is present only for
       backward compatibility purposes and therefore simply returns.  */

    BX      LR                                      // Return to caller
 810040e:	4770      	bx	lr
    LDR     r2, =_tx_thread_preempt_disable         // Build address of preempt disable flag
 8100410:	10000154 	.word	0x10000154
    LDR     r0, =_tx_thread_current_ptr             // Build current thread pointer address
 8100414:	10000030 	.word	0x10000030
    LDR     r2, =_tx_thread_execute_ptr             // Build execute thread pointer address
 8100418:	10000034 	.word	0x10000034
    LDR     r4, =_tx_timer_time_slice               // Build address of time-slice variable
 810041c:	10000224 	.word	0x10000224

08100420 <_tx_timer_interrupt>:
       for use.  */

    /* Increment the system clock.  */
    // _tx_timer_system_clock++;

    LDR     r1, =_tx_timer_system_clock             // Pickup address of system clock
 8100420:	4922      	ldr	r1, [pc, #136]	; (81004ac <__tx_timer_nothing_expired+0x6>)
    LDR     r0, [r1, #0]                            // Pickup system clock
 8100422:	6808      	ldr	r0, [r1, #0]
    ADD     r0, r0, #1                              // Increment system clock
 8100424:	f100 0001 	add.w	r0, r0, #1
    STR     r0, [r1, #0]                            // Store new system clock
 8100428:	6008      	str	r0, [r1, #0]

    /* Test for time-slice expiration.  */
    // if (_tx_timer_time_slice)
    // {

    LDR     r3, =_tx_timer_time_slice               // Pickup address of time-slice
 810042a:	4b21      	ldr	r3, [pc, #132]	; (81004b0 <__tx_timer_nothing_expired+0xa>)
    LDR     r2, [r3, #0]                            // Pickup time-slice
 810042c:	681a      	ldr	r2, [r3, #0]
    CBZ     r2, __tx_timer_no_time_slice            // Is it non-active?
 810042e:	b13a      	cbz	r2, 8100440 <__tx_timer_no_time_slice>
                                                    // Yes, skip time-slice processing

       /* Decrement the time_slice.  */
       // _tx_timer_time_slice--;

    SUB     r2, r2, #1                              // Decrement the time-slice
 8100430:	f1a2 0201 	sub.w	r2, r2, #1
    STR     r2, [r3, #0]                            // Store new time-slice value
 8100434:	601a      	str	r2, [r3, #0]

       /* Check for expiration.  */
       // if (__tx_timer_time_slice == 0)

    CBNZ    r2, __tx_timer_no_time_slice            // Has it expired?
 8100436:	b91a      	cbnz	r2, 8100440 <__tx_timer_no_time_slice>
                                                    // No, skip expiration processing

       /* Set the time-slice expired flag.  */
       // _tx_timer_expired_time_slice =  TX_TRUE;

    LDR     r3, =_tx_timer_expired_time_slice       // Pickup address of expired flag
 8100438:	4b1e      	ldr	r3, [pc, #120]	; (81004b4 <__tx_timer_nothing_expired+0xe>)
    MOV     r0, #1                                  // Build expired value
 810043a:	f04f 0001 	mov.w	r0, #1
    STR     r0, [r3, #0]                            // Set time-slice expiration flag
 810043e:	6018      	str	r0, [r3, #0]

08100440 <__tx_timer_no_time_slice>:

    /* Test for timer expiration.  */
    // if (*_tx_timer_current_ptr)
    // {

    LDR     r1, =_tx_timer_current_ptr              // Pickup current timer pointer address
 8100440:	491d      	ldr	r1, [pc, #116]	; (81004b8 <__tx_timer_nothing_expired+0x12>)
    LDR     r0, [r1, #0]                            // Pickup current timer
 8100442:	6808      	ldr	r0, [r1, #0]
    LDR     r2, [r0, #0]                            // Pickup timer list entry
 8100444:	6802      	ldr	r2, [r0, #0]
    CBZ     r2, __tx_timer_no_timer                 // Is there anything in the list?
 8100446:	b122      	cbz	r2, 8100452 <__tx_timer_no_timer>
                                                    // No, just increment the timer

        /* Set expiration flag.  */
        // _tx_timer_expired =  TX_TRUE;

    LDR     r3, =_tx_timer_expired                  // Pickup expiration flag address
 8100448:	4b1c      	ldr	r3, [pc, #112]	; (81004bc <__tx_timer_nothing_expired+0x16>)
    MOV     r2, #1                                  // Build expired value
 810044a:	f04f 0201 	mov.w	r2, #1
    STR     r2, [r3, #0]                            // Set expired flag
 810044e:	601a      	str	r2, [r3, #0]
    B       __tx_timer_done                         // Finished timer processing
 8100450:	e008      	b.n	8100464 <__tx_timer_done>

08100452 <__tx_timer_no_timer>:
__tx_timer_no_timer:

        /* No timer expired, increment the timer pointer.  */
        // _tx_timer_current_ptr++;

    ADD     r0, r0, #4                              // Move to next timer
 8100452:	f100 0004 	add.w	r0, r0, #4

        /* Check for wrap-around.  */
        // if (_tx_timer_current_ptr == _tx_timer_list_end)

    LDR     r3, =_tx_timer_list_end                 // Pickup addr of timer list end
 8100456:	4b1a      	ldr	r3, [pc, #104]	; (81004c0 <__tx_timer_nothing_expired+0x1a>)
    LDR     r2, [r3, #0]                            // Pickup list end
 8100458:	681a      	ldr	r2, [r3, #0]
    CMP     r0, r2                                  // Are we at list end?
 810045a:	4290      	cmp	r0, r2
    BNE     __tx_timer_skip_wrap                    // No, skip wrap-around logic
 810045c:	d101      	bne.n	8100462 <__tx_timer_skip_wrap>

            /* Wrap to beginning of list.  */
            // _tx_timer_current_ptr =  _tx_timer_list_start;

    LDR     r3, =_tx_timer_list_start               // Pickup addr of timer list start
 810045e:	4b19      	ldr	r3, [pc, #100]	; (81004c4 <__tx_timer_nothing_expired+0x1e>)
    LDR     r0, [r3, #0]                            // Set current pointer to list start
 8100460:	6818      	ldr	r0, [r3, #0]

08100462 <__tx_timer_skip_wrap>:

__tx_timer_skip_wrap:

    STR     r0, [r1, #0]                            // Store new current timer pointer
 8100462:	6008      	str	r0, [r1, #0]

08100464 <__tx_timer_done>:

    /* See if anything has expired.  */
    // if ((_tx_timer_expired_time_slice) || (_tx_timer_expired))
    // {

    LDR     r3, =_tx_timer_expired_time_slice       // Pickup addr of expired flag
 8100464:	4b13      	ldr	r3, [pc, #76]	; (81004b4 <__tx_timer_nothing_expired+0xe>)
    LDR     r2, [r3, #0]                            // Pickup time-slice expired flag
 8100466:	681a      	ldr	r2, [r3, #0]
    CBNZ    r2, __tx_something_expired              // Did a time-slice expire?
 8100468:	b912      	cbnz	r2, 8100470 <__tx_something_expired>
                                                    // If non-zero, time-slice expired
    LDR     r1, =_tx_timer_expired                  // Pickup addr of other expired flag
 810046a:	4914      	ldr	r1, [pc, #80]	; (81004bc <__tx_timer_nothing_expired+0x16>)
    LDR     r0, [r1, #0]                            // Pickup timer expired flag
 810046c:	6808      	ldr	r0, [r1, #0]
    CBZ     r0, __tx_timer_nothing_expired          // Did a timer expire?
 810046e:	b1d0      	cbz	r0, 81004a6 <__tx_timer_nothing_expired>

08100470 <__tx_something_expired>:
                                                    // No, nothing expired

__tx_something_expired:

    STMDB   sp!, {r0, lr}                           // Save the lr register on the stack
 8100470:	e92d 4001 	stmdb	sp!, {r0, lr}

    /* Did a timer expire?  */
    // if (_tx_timer_expired)
    // {

    LDR     r1, =_tx_timer_expired                  // Pickup addr of expired flag
 8100474:	4911      	ldr	r1, [pc, #68]	; (81004bc <__tx_timer_nothing_expired+0x16>)
    LDR     r0, [r1, #0]                            // Pickup timer expired flag
 8100476:	6808      	ldr	r0, [r1, #0]
    CBZ     r0, __tx_timer_dont_activate            // Check for timer expiration
 8100478:	b108      	cbz	r0, 810047e <__tx_timer_dont_activate>
                                                    // If not set, skip timer activation

        /* Process timer expiration.  */
        // _tx_timer_expiration_process();

    BL      _tx_timer_expiration_process            // Call the timer expiration handling routine
 810047a:	f001 f817 	bl	81014ac <_tx_timer_expiration_process>

0810047e <__tx_timer_dont_activate>:

    /* Did time slice expire?  */
    // if (_tx_timer_expired_time_slice)
    // {

    LDR     r3, =_tx_timer_expired_time_slice       // Pickup addr of time-slice expired
 810047e:	4b0d      	ldr	r3, [pc, #52]	; (81004b4 <__tx_timer_nothing_expired+0xe>)
    LDR     r2, [r3, #0]                            // Pickup the actual flag
 8100480:	681a      	ldr	r2, [r3, #0]
    CBZ     r2, __tx_timer_not_ts_expiration        // See if the flag is set
 8100482:	b172      	cbz	r2, 81004a2 <__tx_timer_not_ts_expiration>
                                                    // No, skip time-slice processing

        /* Time slice interrupted thread.  */
        // _tx_thread_time_slice();

    BL      _tx_thread_time_slice                   // Call time-slice processing
 8100484:	f000 ffc0 	bl	8101408 <_tx_thread_time_slice>
    LDR     r0, =_tx_thread_preempt_disable         // Build address of preempt disable flag
 8100488:	480f      	ldr	r0, [pc, #60]	; (81004c8 <__tx_timer_nothing_expired+0x22>)
    LDR     r1, [r0]                                // Is the preempt disable flag set?
 810048a:	6801      	ldr	r1, [r0, #0]
    CBNZ    r1, __tx_timer_skip_time_slice          // Yes, skip the PendSV logic
 810048c:	b949      	cbnz	r1, 81004a2 <__tx_timer_not_ts_expiration>
    LDR     r0, =_tx_thread_current_ptr             // Build current thread pointer address
 810048e:	480f      	ldr	r0, [pc, #60]	; (81004cc <__tx_timer_nothing_expired+0x26>)
    LDR     r1, [r0]                                // Pickup the current thread pointer
 8100490:	6801      	ldr	r1, [r0, #0]
    LDR     r2, =_tx_thread_execute_ptr             // Build execute thread pointer address
 8100492:	4a0f      	ldr	r2, [pc, #60]	; (81004d0 <__tx_timer_nothing_expired+0x2a>)
    LDR     r3, [r2]                                // Pickup the execute thread pointer
 8100494:	6813      	ldr	r3, [r2, #0]
    LDR     r0, =0xE000ED04                         // Build address of control register
 8100496:	480f      	ldr	r0, [pc, #60]	; (81004d4 <__tx_timer_nothing_expired+0x2e>)
    LDR     r2, =0x10000000                         // Build value for PendSV bit
 8100498:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
    CMP     r1, r3                                  // Are they the same?
 810049c:	4299      	cmp	r1, r3
    BEQ     __tx_timer_skip_time_slice              // If the same, there was no time-slice performed
 810049e:	d000      	beq.n	81004a2 <__tx_timer_not_ts_expiration>
    STR     r2, [r0]                                // Not the same, issue the PendSV for preemption
 81004a0:	6002      	str	r2, [r0, #0]

081004a2 <__tx_timer_not_ts_expiration>:

    // }

__tx_timer_not_ts_expiration:

    LDMIA   sp!, {r0, lr}                           // Recover lr register (r0 is just there for
 81004a2:	e8bd 4001 	ldmia.w	sp!, {r0, lr}

081004a6 <__tx_timer_nothing_expired>:

    // }

__tx_timer_nothing_expired:

    DSB                                             // Complete all memory access
 81004a6:	f3bf 8f4f 	dsb	sy
    BX      lr                                      // Return to caller
 81004aa:	4770      	bx	lr
    LDR     r1, =_tx_timer_system_clock             // Pickup address of system clock
 81004ac:	10000158 	.word	0x10000158
    LDR     r3, =_tx_timer_time_slice               // Pickup address of time-slice
 81004b0:	10000224 	.word	0x10000224
    LDR     r3, =_tx_timer_expired_time_slice       // Pickup address of expired flag
 81004b4:	1000015c 	.word	0x1000015c
    LDR     r1, =_tx_timer_current_ptr              // Pickup current timer pointer address
 81004b8:	10000168 	.word	0x10000168
    LDR     r3, =_tx_timer_expired                  // Pickup expiration flag address
 81004bc:	1000016c 	.word	0x1000016c
    LDR     r3, =_tx_timer_list_end                 // Pickup addr of timer list end
 81004c0:	10000164 	.word	0x10000164
    LDR     r3, =_tx_timer_list_start               // Pickup addr of timer list start
 81004c4:	10000160 	.word	0x10000160
    LDR     r0, =_tx_thread_preempt_disable         // Build address of preempt disable flag
 81004c8:	10000154 	.word	0x10000154
    LDR     r0, =_tx_thread_current_ptr             // Build current thread pointer address
 81004cc:	10000030 	.word	0x10000030
    LDR     r2, =_tx_thread_execute_ptr             // Build execute thread pointer address
 81004d0:	10000034 	.word	0x10000034
    LDR     r0, =0xE000ED04                         // Build address of control register
 81004d4:	e000ed04 	.word	0xe000ed04

081004d8 <main>:
/**
  * @brief  The application entry point.
  * @retval int
  */
int main(void)
{
 81004d8:	b580      	push	{r7, lr}
 81004da:	b082      	sub	sp, #8
 81004dc:	af00      	add	r7, sp, #0

  /* USER CODE END 1 */

/* USER CODE BEGIN Boot_Mode_Sequence_1 */
  /*HW semaphore Clock enable*/
  __HAL_RCC_HSEM_CLK_ENABLE();
 81004de:	4b1b      	ldr	r3, [pc, #108]	; (810054c <main+0x74>)
 81004e0:	f8d3 30e0 	ldr.w	r3, [r3, #224]	; 0xe0
 81004e4:	4a19      	ldr	r2, [pc, #100]	; (810054c <main+0x74>)
 81004e6:	f043 7300 	orr.w	r3, r3, #33554432	; 0x2000000
 81004ea:	f8c2 30e0 	str.w	r3, [r2, #224]	; 0xe0
 81004ee:	4b17      	ldr	r3, [pc, #92]	; (810054c <main+0x74>)
 81004f0:	f8d3 30e0 	ldr.w	r3, [r3, #224]	; 0xe0
 81004f4:	f003 7300 	and.w	r3, r3, #33554432	; 0x2000000
 81004f8:	607b      	str	r3, [r7, #4]
 81004fa:	687b      	ldr	r3, [r7, #4]
  /* Activate HSEM notification for Cortex-M4*/
  HAL_HSEM_ActivateNotification(__HAL_HSEM_SEMID_TO_MASK(HSEM_ID_0));
 81004fc:	2001      	movs	r0, #1
 81004fe:	f000 fc27 	bl	8100d50 <HAL_HSEM_ActivateNotification>
  /*
  Domain D2 goes to STOP mode (Cortex-M4 in deep-sleep) waiting for Cortex-M7 to
  perform system initialization (system clock config, external memory configuration.. )
  */
  HAL_PWREx_ClearPendingEvent();
 8100502:	f000 fcb1 	bl	8100e68 <HAL_PWREx_ClearPendingEvent>
  HAL_PWREx_EnterSTOPMode(PWR_MAINREGULATOR_ON, PWR_STOPENTRY_WFE, PWR_D2_DOMAIN);
 8100506:	2201      	movs	r2, #1
 8100508:	2102      	movs	r1, #2
 810050a:	2000      	movs	r0, #0
 810050c:	f000 fc32 	bl	8100d74 <HAL_PWREx_EnterSTOPMode>
  /* Clear HSEM flag */
  __HAL_HSEM_CLEAR_FLAG(__HAL_HSEM_SEMID_TO_MASK(HSEM_ID_0));
 8100510:	4b0f      	ldr	r3, [pc, #60]	; (8100550 <main+0x78>)
 8100512:	681b      	ldr	r3, [r3, #0]
 8100514:	091b      	lsrs	r3, r3, #4
 8100516:	f003 030f 	and.w	r3, r3, #15
 810051a:	2b07      	cmp	r3, #7
 810051c:	d108      	bne.n	8100530 <main+0x58>
 810051e:	4b0d      	ldr	r3, [pc, #52]	; (8100554 <main+0x7c>)
 8100520:	f8d3 3104 	ldr.w	r3, [r3, #260]	; 0x104
 8100524:	4a0b      	ldr	r2, [pc, #44]	; (8100554 <main+0x7c>)
 8100526:	f043 0301 	orr.w	r3, r3, #1
 810052a:	f8c2 3104 	str.w	r3, [r2, #260]	; 0x104
 810052e:	e007      	b.n	8100540 <main+0x68>
 8100530:	4b08      	ldr	r3, [pc, #32]	; (8100554 <main+0x7c>)
 8100532:	f8d3 3114 	ldr.w	r3, [r3, #276]	; 0x114
 8100536:	4a07      	ldr	r2, [pc, #28]	; (8100554 <main+0x7c>)
 8100538:	f043 0301 	orr.w	r3, r3, #1
 810053c:	f8c2 3114 	str.w	r3, [r2, #276]	; 0x114

/* USER CODE END Boot_Mode_Sequence_1 */
  /* MCU Configuration--------------------------------------------------------*/

  /* Reset of all peripherals, Initializes the Flash interface and the Systick. */
  HAL_Init();
 8100540:	f000 f8b0 	bl	81006a4 <HAL_Init>
  /* USER CODE BEGIN SysInit */

  /* USER CODE END SysInit */

  /* Initialize all configured peripherals */
  MX_GPIO_Init();
 8100544:	f000 f808 	bl	8100558 <MX_GPIO_Init>

  /* USER CODE END 2 */

  /* Infinite loop */
  /* USER CODE BEGIN WHILE */
  while (1)
 8100548:	e7fe      	b.n	8100548 <main+0x70>
 810054a:	bf00      	nop
 810054c:	58024400 	.word	0x58024400
 8100550:	e000ed00 	.word	0xe000ed00
 8100554:	58026400 	.word	0x58026400

08100558 <MX_GPIO_Init>:
  * @brief GPIO Initialization Function
  * @param None
  * @retval None
  */
static void MX_GPIO_Init(void)
{
 8100558:	b580      	push	{r7, lr}
 810055a:	b086      	sub	sp, #24
 810055c:	af00      	add	r7, sp, #0
  GPIO_InitTypeDef GPIO_InitStruct = {0};
 810055e:	1d3b      	adds	r3, r7, #4
 8100560:	2200      	movs	r2, #0
 8100562:	601a      	str	r2, [r3, #0]
 8100564:	605a      	str	r2, [r3, #4]
 8100566:	609a      	str	r2, [r3, #8]
 8100568:	60da      	str	r2, [r3, #12]
 810056a:	611a      	str	r2, [r3, #16]

  /* GPIO Ports Clock Enable */
  __HAL_RCC_GPIOK_CLK_ENABLE();
 810056c:	4b12      	ldr	r3, [pc, #72]	; (81005b8 <MX_GPIO_Init+0x60>)
 810056e:	f8d3 30e0 	ldr.w	r3, [r3, #224]	; 0xe0
 8100572:	4a11      	ldr	r2, [pc, #68]	; (81005b8 <MX_GPIO_Init+0x60>)
 8100574:	f443 6380 	orr.w	r3, r3, #1024	; 0x400
 8100578:	f8c2 30e0 	str.w	r3, [r2, #224]	; 0xe0
 810057c:	4b0e      	ldr	r3, [pc, #56]	; (81005b8 <MX_GPIO_Init+0x60>)
 810057e:	f8d3 30e0 	ldr.w	r3, [r3, #224]	; 0xe0
 8100582:	f403 6380 	and.w	r3, r3, #1024	; 0x400
 8100586:	603b      	str	r3, [r7, #0]
 8100588:	683b      	ldr	r3, [r7, #0]

  /*Configure GPIO pin Output Level */
  HAL_GPIO_WritePin(GPIOK, GPIO_PIN_5, GPIO_PIN_RESET);
 810058a:	2200      	movs	r2, #0
 810058c:	2120      	movs	r1, #32
 810058e:	480b      	ldr	r0, [pc, #44]	; (81005bc <MX_GPIO_Init+0x64>)
 8100590:	f000 fbc4 	bl	8100d1c <HAL_GPIO_WritePin>

  /*Configure GPIO pin : PK5 */
  GPIO_InitStruct.Pin = GPIO_PIN_5;
 8100594:	2320      	movs	r3, #32
 8100596:	607b      	str	r3, [r7, #4]
  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
 8100598:	2301      	movs	r3, #1
 810059a:	60bb      	str	r3, [r7, #8]
  GPIO_InitStruct.Pull = GPIO_NOPULL;
 810059c:	2300      	movs	r3, #0
 810059e:	60fb      	str	r3, [r7, #12]
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
 81005a0:	2300      	movs	r3, #0
 81005a2:	613b      	str	r3, [r7, #16]
  HAL_GPIO_Init(GPIOK, &GPIO_InitStruct);
 81005a4:	1d3b      	adds	r3, r7, #4
 81005a6:	4619      	mov	r1, r3
 81005a8:	4804      	ldr	r0, [pc, #16]	; (81005bc <MX_GPIO_Init+0x64>)
 81005aa:	f000 fa07 	bl	81009bc <HAL_GPIO_Init>

}
 81005ae:	bf00      	nop
 81005b0:	3718      	adds	r7, #24
 81005b2:	46bd      	mov	sp, r7
 81005b4:	bd80      	pop	{r7, pc}
 81005b6:	bf00      	nop
 81005b8:	58024400 	.word	0x58024400
 81005bc:	58022800 	.word	0x58022800

081005c0 <Reset_Handler>:

    .section  .text.Reset_Handler
  .weak  Reset_Handler
  .type  Reset_Handler, %function
Reset_Handler:
  ldr   sp, =_estack      /* set stack pointer */
 81005c0:	f8df d034 	ldr.w	sp, [pc, #52]	; 81005f8 <LoopFillZerobss+0xe>

/* Call the clock system initialization function.*/
  bl  SystemInit
 81005c4:	f000 f856 	bl	8100674 <SystemInit>

/* Copy the data segment initializers from flash to SRAM */
  ldr r0, =_sdata
 81005c8:	480c      	ldr	r0, [pc, #48]	; (81005fc <LoopFillZerobss+0x12>)
  ldr r1, =_edata
 81005ca:	490d      	ldr	r1, [pc, #52]	; (8100600 <LoopFillZerobss+0x16>)
  ldr r2, =_sidata
 81005cc:	4a0d      	ldr	r2, [pc, #52]	; (8100604 <LoopFillZerobss+0x1a>)
  movs r3, #0
 81005ce:	2300      	movs	r3, #0
  b LoopCopyDataInit
 81005d0:	e002      	b.n	81005d8 <LoopCopyDataInit>

081005d2 <CopyDataInit>:

CopyDataInit:
  ldr r4, [r2, r3]
 81005d2:	58d4      	ldr	r4, [r2, r3]
  str r4, [r0, r3]
 81005d4:	50c4      	str	r4, [r0, r3]
  adds r3, r3, #4
 81005d6:	3304      	adds	r3, #4

081005d8 <LoopCopyDataInit>:

LoopCopyDataInit:
  adds r4, r0, r3
 81005d8:	18c4      	adds	r4, r0, r3
  cmp r4, r1
 81005da:	428c      	cmp	r4, r1
  bcc CopyDataInit
 81005dc:	d3f9      	bcc.n	81005d2 <CopyDataInit>
/* Zero fill the bss segment. */
  ldr r2, =_sbss
 81005de:	4a0a      	ldr	r2, [pc, #40]	; (8100608 <LoopFillZerobss+0x1e>)
  ldr r4, =_ebss
 81005e0:	4c0a      	ldr	r4, [pc, #40]	; (810060c <LoopFillZerobss+0x22>)
  movs r3, #0
 81005e2:	2300      	movs	r3, #0
  b LoopFillZerobss
 81005e4:	e001      	b.n	81005ea <LoopFillZerobss>

081005e6 <FillZerobss>:

FillZerobss:
  str  r3, [r2]
 81005e6:	6013      	str	r3, [r2, #0]
  adds r2, r2, #4
 81005e8:	3204      	adds	r2, #4

081005ea <LoopFillZerobss>:

LoopFillZerobss:
  cmp r2, r4
 81005ea:	42a2      	cmp	r2, r4
  bcc FillZerobss
 81005ec:	d3fb      	bcc.n	81005e6 <FillZerobss>

/* Call static constructors */
    bl __libc_init_array
 81005ee:	f000 ffb7 	bl	8101560 <__libc_init_array>
/* Call the application's entry point.*/
  bl  main
 81005f2:	f7ff ff71 	bl	81004d8 <main>
  bx  lr
 81005f6:	4770      	bx	lr
  ldr   sp, =_estack      /* set stack pointer */
 81005f8:	10048000 	.word	0x10048000
  ldr r0, =_sdata
 81005fc:	10000000 	.word	0x10000000
  ldr r1, =_edata
 8100600:	10000010 	.word	0x10000010
  ldr r2, =_sidata
 8100604:	081015d8 	.word	0x081015d8
  ldr r2, =_sbss
 8100608:	10000010 	.word	0x10000010
  ldr r4, =_ebss
 810060c:	10000228 	.word	0x10000228

08100610 <ADC3_IRQHandler>:
 * @retval None
*/
    .section  .text.Default_Handler,"ax",%progbits
Default_Handler:
Infinite_Loop:
  b  Infinite_Loop
 8100610:	e7fe      	b.n	8100610 <ADC3_IRQHandler>
	...

08100614 <HAL_MspInit>:
/* USER CODE END 0 */
/**
  * Initializes the Global MSP.
  */
void HAL_MspInit(void)
{
 8100614:	b480      	push	{r7}
 8100616:	b083      	sub	sp, #12
 8100618:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN MspInit 0 */

  /* USER CODE END MspInit 0 */

  __HAL_RCC_SYSCFG_CLK_ENABLE();
 810061a:	4b0a      	ldr	r3, [pc, #40]	; (8100644 <HAL_MspInit+0x30>)
 810061c:	f8d3 30f4 	ldr.w	r3, [r3, #244]	; 0xf4
 8100620:	4a08      	ldr	r2, [pc, #32]	; (8100644 <HAL_MspInit+0x30>)
 8100622:	f043 0302 	orr.w	r3, r3, #2
 8100626:	f8c2 30f4 	str.w	r3, [r2, #244]	; 0xf4
 810062a:	4b06      	ldr	r3, [pc, #24]	; (8100644 <HAL_MspInit+0x30>)
 810062c:	f8d3 30f4 	ldr.w	r3, [r3, #244]	; 0xf4
 8100630:	f003 0302 	and.w	r3, r3, #2
 8100634:	607b      	str	r3, [r7, #4]
 8100636:	687b      	ldr	r3, [r7, #4]
  /* System interrupt init*/

  /* USER CODE BEGIN MspInit 1 */

  /* USER CODE END MspInit 1 */
}
 8100638:	bf00      	nop
 810063a:	370c      	adds	r7, #12
 810063c:	46bd      	mov	sp, r7
 810063e:	f85d 7b04 	ldr.w	r7, [sp], #4
 8100642:	4770      	bx	lr
 8100644:	58024400 	.word	0x58024400

08100648 <NMI_Handler>:
/******************************************************************************/
/**
  * @brief This function handles Non maskable interrupt.
  */
void NMI_Handler(void)
{
 8100648:	b480      	push	{r7}
 810064a:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN NonMaskableInt_IRQn 0 */

  /* USER CODE END NonMaskableInt_IRQn 0 */
  /* USER CODE BEGIN NonMaskableInt_IRQn 1 */
  while (1)
 810064c:	e7fe      	b.n	810064c <NMI_Handler+0x4>

0810064e <HardFault_Handler>:

/**
  * @brief This function handles Hard fault interrupt.
  */
void HardFault_Handler(void)
{
 810064e:	b480      	push	{r7}
 8100650:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN HardFault_IRQn 0 */

  /* USER CODE END HardFault_IRQn 0 */
  while (1)
 8100652:	e7fe      	b.n	8100652 <HardFault_Handler+0x4>

08100654 <MemManage_Handler>:

/**
  * @brief This function handles Memory management fault.
  */
void MemManage_Handler(void)
{
 8100654:	b480      	push	{r7}
 8100656:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN MemoryManagement_IRQn 0 */

  /* USER CODE END MemoryManagement_IRQn 0 */
  while (1)
 8100658:	e7fe      	b.n	8100658 <MemManage_Handler+0x4>

0810065a <BusFault_Handler>:

/**
  * @brief This function handles Pre-fetch fault, memory access fault.
  */
void BusFault_Handler(void)
{
 810065a:	b480      	push	{r7}
 810065c:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN BusFault_IRQn 0 */

  /* USER CODE END BusFault_IRQn 0 */
  while (1)
 810065e:	e7fe      	b.n	810065e <BusFault_Handler+0x4>

08100660 <UsageFault_Handler>:

/**
  * @brief This function handles Undefined instruction or illegal state.
  */
void UsageFault_Handler(void)
{
 8100660:	b480      	push	{r7}
 8100662:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN UsageFault_IRQn 0 */

  /* USER CODE END UsageFault_IRQn 0 */
  while (1)
 8100664:	e7fe      	b.n	8100664 <UsageFault_Handler+0x4>

08100666 <DebugMon_Handler>:

/**
  * @brief This function handles Debug monitor.
  */
void DebugMon_Handler(void)
{
 8100666:	b480      	push	{r7}
 8100668:	af00      	add	r7, sp, #0

  /* USER CODE END DebugMonitor_IRQn 0 */
  /* USER CODE BEGIN DebugMonitor_IRQn 1 */

  /* USER CODE END DebugMonitor_IRQn 1 */
}
 810066a:	bf00      	nop
 810066c:	46bd      	mov	sp, r7
 810066e:	f85d 7b04 	ldr.w	r7, [sp], #4
 8100672:	4770      	bx	lr

08100674 <SystemInit>:
  *         configuration.
  * @param  None
  * @retval None
  */
void SystemInit (void)
{
 8100674:	b480      	push	{r7}
 8100676:	af00      	add	r7, sp, #0
  /* FPU settings ------------------------------------------------------------*/
  #if (__FPU_PRESENT == 1) && (__FPU_USED == 1)
    SCB->CPACR |= ((3UL << (10*2))|(3UL << (11*2)));  /* set CP10 and CP11 Full Access */
 8100678:	4b09      	ldr	r3, [pc, #36]	; (81006a0 <SystemInit+0x2c>)
 810067a:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
 810067e:	4a08      	ldr	r2, [pc, #32]	; (81006a0 <SystemInit+0x2c>)
 8100680:	f443 0370 	orr.w	r3, r3, #15728640	; 0xf00000
 8100684:	f8c2 3088 	str.w	r3, [r2, #136]	; 0x88
  #endif

    /*SEVONPEND enabled so that an interrupt coming from the CPU(n) interrupt signal is
     detectable by the CPU after a WFI/WFE instruction.*/
 SCB->SCR |= SCB_SCR_SEVONPEND_Msk;
 8100688:	4b05      	ldr	r3, [pc, #20]	; (81006a0 <SystemInit+0x2c>)
 810068a:	691b      	ldr	r3, [r3, #16]
 810068c:	4a04      	ldr	r2, [pc, #16]	; (81006a0 <SystemInit+0x2c>)
 810068e:	f043 0310 	orr.w	r3, r3, #16
 8100692:	6113      	str	r3, [r2, #16]
#endif /* USER_VECT_TAB_ADDRESS */

#else
#error Please #define CORE_CM4 or CORE_CM7
#endif /* CORE_CM4 */
}
 8100694:	bf00      	nop
 8100696:	46bd      	mov	sp, r7
 8100698:	f85d 7b04 	ldr.w	r7, [sp], #4
 810069c:	4770      	bx	lr
 810069e:	bf00      	nop
 81006a0:	e000ed00 	.word	0xe000ed00

081006a4 <HAL_Init>:
  *         need to ensure that the SysTick time base is always set to 1 millisecond
  *         to have correct HAL operation.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_Init(void)
{
 81006a4:	b580      	push	{r7, lr}
 81006a6:	b082      	sub	sp, #8
 81006a8:	af00      	add	r7, sp, #0

uint32_t common_system_clock;

#if defined(DUAL_CORE) && defined(CORE_CM4)
   /* Configure Cortex-M4 Instruction cache through ART accelerator */
   __HAL_RCC_ART_CLK_ENABLE();                   /* Enable the Cortex-M4 ART Clock */
 81006aa:	4b28      	ldr	r3, [pc, #160]	; (810074c <HAL_Init+0xa8>)
 81006ac:	f8d3 30d8 	ldr.w	r3, [r3, #216]	; 0xd8
 81006b0:	4a26      	ldr	r2, [pc, #152]	; (810074c <HAL_Init+0xa8>)
 81006b2:	f443 4380 	orr.w	r3, r3, #16384	; 0x4000
 81006b6:	f8c2 30d8 	str.w	r3, [r2, #216]	; 0xd8
 81006ba:	4b24      	ldr	r3, [pc, #144]	; (810074c <HAL_Init+0xa8>)
 81006bc:	f8d3 30d8 	ldr.w	r3, [r3, #216]	; 0xd8
 81006c0:	f403 4380 	and.w	r3, r3, #16384	; 0x4000
 81006c4:	603b      	str	r3, [r7, #0]
 81006c6:	683b      	ldr	r3, [r7, #0]
   __HAL_ART_CONFIG_BASE_ADDRESS(0x08100000UL);  /* Configure the Cortex-M4 ART Base address to the Flash Bank 2 : */
 81006c8:	4b21      	ldr	r3, [pc, #132]	; (8100750 <HAL_Init+0xac>)
 81006ca:	681b      	ldr	r3, [r3, #0]
 81006cc:	f423 237f 	bic.w	r3, r3, #1044480	; 0xff000
 81006d0:	f423 6370 	bic.w	r3, r3, #3840	; 0xf00
 81006d4:	4a1e      	ldr	r2, [pc, #120]	; (8100750 <HAL_Init+0xac>)
 81006d6:	f443 4301 	orr.w	r3, r3, #33024	; 0x8100
 81006da:	6013      	str	r3, [r2, #0]
   __HAL_ART_ENABLE();                           /* Enable the Cortex-M4 ART */
 81006dc:	4b1c      	ldr	r3, [pc, #112]	; (8100750 <HAL_Init+0xac>)
 81006de:	681b      	ldr	r3, [r3, #0]
 81006e0:	4a1b      	ldr	r2, [pc, #108]	; (8100750 <HAL_Init+0xac>)
 81006e2:	f043 0301 	orr.w	r3, r3, #1
 81006e6:	6013      	str	r3, [r2, #0]
#endif /* DUAL_CORE &&  CORE_CM4 */

  /* Set Interrupt Group Priority */
  HAL_NVIC_SetPriorityGrouping(NVIC_PRIORITYGROUP_4);
 81006e8:	2003      	movs	r0, #3
 81006ea:	f000 f921 	bl	8100930 <HAL_NVIC_SetPriorityGrouping>

  /* Update the SystemCoreClock global variable */
#if defined(RCC_D1CFGR_D1CPRE)
  common_system_clock = HAL_RCC_GetSysClockFreq() >> ((D1CorePrescTable[(RCC->D1CFGR & RCC_D1CFGR_D1CPRE)>> RCC_D1CFGR_D1CPRE_Pos]) & 0x1FU);
 81006ee:	f000 fbc9 	bl	8100e84 <HAL_RCC_GetSysClockFreq>
 81006f2:	4602      	mov	r2, r0
 81006f4:	4b15      	ldr	r3, [pc, #84]	; (810074c <HAL_Init+0xa8>)
 81006f6:	699b      	ldr	r3, [r3, #24]
 81006f8:	0a1b      	lsrs	r3, r3, #8
 81006fa:	f003 030f 	and.w	r3, r3, #15
 81006fe:	4915      	ldr	r1, [pc, #84]	; (8100754 <HAL_Init+0xb0>)
 8100700:	5ccb      	ldrb	r3, [r1, r3]
 8100702:	f003 031f 	and.w	r3, r3, #31
 8100706:	fa22 f303 	lsr.w	r3, r2, r3
 810070a:	607b      	str	r3, [r7, #4]
  common_system_clock = HAL_RCC_GetSysClockFreq() >> ((D1CorePrescTable[(RCC->CDCFGR1 & RCC_CDCFGR1_CDCPRE)>> RCC_CDCFGR1_CDCPRE_Pos]) & 0x1FU);
#endif

  /* Update the SystemD2Clock global variable */
#if defined(RCC_D1CFGR_HPRE)
  SystemD2Clock = (common_system_clock >> ((D1CorePrescTable[(RCC->D1CFGR & RCC_D1CFGR_HPRE)>> RCC_D1CFGR_HPRE_Pos]) & 0x1FU));
 810070c:	4b0f      	ldr	r3, [pc, #60]	; (810074c <HAL_Init+0xa8>)
 810070e:	699b      	ldr	r3, [r3, #24]
 8100710:	f003 030f 	and.w	r3, r3, #15
 8100714:	4a0f      	ldr	r2, [pc, #60]	; (8100754 <HAL_Init+0xb0>)
 8100716:	5cd3      	ldrb	r3, [r2, r3]
 8100718:	f003 031f 	and.w	r3, r3, #31
 810071c:	687a      	ldr	r2, [r7, #4]
 810071e:	fa22 f303 	lsr.w	r3, r2, r3
 8100722:	4a0d      	ldr	r2, [pc, #52]	; (8100758 <HAL_Init+0xb4>)
 8100724:	6013      	str	r3, [r2, #0]
#else
  SystemD2Clock = (common_system_clock >> ((D1CorePrescTable[(RCC->CDCFGR1 & RCC_CDCFGR1_HPRE)>> RCC_CDCFGR1_HPRE_Pos]) & 0x1FU));
#endif

#if defined(DUAL_CORE) && defined(CORE_CM4)
  SystemCoreClock = SystemD2Clock;
 8100726:	4b0c      	ldr	r3, [pc, #48]	; (8100758 <HAL_Init+0xb4>)
 8100728:	681b      	ldr	r3, [r3, #0]
 810072a:	4a0c      	ldr	r2, [pc, #48]	; (810075c <HAL_Init+0xb8>)
 810072c:	6013      	str	r3, [r2, #0]
#else
  SystemCoreClock = common_system_clock;
#endif /* DUAL_CORE && CORE_CM4 */

  /* Use systick as time base source and configure 1ms tick (default clock after Reset is HSI) */
  if(HAL_InitTick(TICK_INT_PRIORITY) != HAL_OK)
 810072e:	2000      	movs	r0, #0
 8100730:	f000 f816 	bl	8100760 <HAL_InitTick>
 8100734:	4603      	mov	r3, r0
 8100736:	2b00      	cmp	r3, #0
 8100738:	d001      	beq.n	810073e <HAL_Init+0x9a>
  {
    return HAL_ERROR;
 810073a:	2301      	movs	r3, #1
 810073c:	e002      	b.n	8100744 <HAL_Init+0xa0>
  }

  /* Init the low level hardware */
  HAL_MspInit();
 810073e:	f7ff ff69 	bl	8100614 <HAL_MspInit>

  /* Return function status */
  return HAL_OK;
 8100742:	2300      	movs	r3, #0
}
 8100744:	4618      	mov	r0, r3
 8100746:	3708      	adds	r7, #8
 8100748:	46bd      	mov	sp, r7
 810074a:	bd80      	pop	{r7, pc}
 810074c:	58024400 	.word	0x58024400
 8100750:	40024400 	.word	0x40024400
 8100754:	081015c0 	.word	0x081015c0
 8100758:	10000004 	.word	0x10000004
 810075c:	10000000 	.word	0x10000000

08100760 <HAL_InitTick>:
  *       implementation  in user file.
  * @param TickPriority: Tick interrupt priority.
  * @retval HAL status
  */
__weak HAL_StatusTypeDef HAL_InitTick(uint32_t TickPriority)
{
 8100760:	b580      	push	{r7, lr}
 8100762:	b082      	sub	sp, #8
 8100764:	af00      	add	r7, sp, #0
 8100766:	6078      	str	r0, [r7, #4]
  /* Check uwTickFreq for MisraC 2012 (even if uwTickFreq is a enum type that don't take the value zero)*/
  if((uint32_t)uwTickFreq == 0UL)
 8100768:	4b15      	ldr	r3, [pc, #84]	; (81007c0 <HAL_InitTick+0x60>)
 810076a:	781b      	ldrb	r3, [r3, #0]
 810076c:	2b00      	cmp	r3, #0
 810076e:	d101      	bne.n	8100774 <HAL_InitTick+0x14>
  {
    return HAL_ERROR;
 8100770:	2301      	movs	r3, #1
 8100772:	e021      	b.n	81007b8 <HAL_InitTick+0x58>
  }

    /* Configure the SysTick to have interrupt in 1ms time basis*/
    if (HAL_SYSTICK_Config(SystemCoreClock / (1000UL / (uint32_t)uwTickFreq)) > 0U)
 8100774:	4b13      	ldr	r3, [pc, #76]	; (81007c4 <HAL_InitTick+0x64>)
 8100776:	681a      	ldr	r2, [r3, #0]
 8100778:	4b11      	ldr	r3, [pc, #68]	; (81007c0 <HAL_InitTick+0x60>)
 810077a:	781b      	ldrb	r3, [r3, #0]
 810077c:	4619      	mov	r1, r3
 810077e:	f44f 737a 	mov.w	r3, #1000	; 0x3e8
 8100782:	fbb3 f3f1 	udiv	r3, r3, r1
 8100786:	fbb2 f3f3 	udiv	r3, r2, r3
 810078a:	4618      	mov	r0, r3
 810078c:	f000 f8f5 	bl	810097a <HAL_SYSTICK_Config>
 8100790:	4603      	mov	r3, r0
 8100792:	2b00      	cmp	r3, #0
 8100794:	d001      	beq.n	810079a <HAL_InitTick+0x3a>
    {
      return HAL_ERROR;
 8100796:	2301      	movs	r3, #1
 8100798:	e00e      	b.n	81007b8 <HAL_InitTick+0x58>
    }

  /* Configure the SysTick IRQ priority */
  if (TickPriority < (1UL << __NVIC_PRIO_BITS))
 810079a:	687b      	ldr	r3, [r7, #4]
 810079c:	2b0f      	cmp	r3, #15
 810079e:	d80a      	bhi.n	81007b6 <HAL_InitTick+0x56>
  {
    HAL_NVIC_SetPriority(SysTick_IRQn, TickPriority, 0U);
 81007a0:	2200      	movs	r2, #0
 81007a2:	6879      	ldr	r1, [r7, #4]
 81007a4:	f04f 30ff 	mov.w	r0, #4294967295
 81007a8:	f000 f8cd 	bl	8100946 <HAL_NVIC_SetPriority>
    uwTickPrio = TickPriority;
 81007ac:	4a06      	ldr	r2, [pc, #24]	; (81007c8 <HAL_InitTick+0x68>)
 81007ae:	687b      	ldr	r3, [r7, #4]
 81007b0:	6013      	str	r3, [r2, #0]
  {
    return HAL_ERROR;
  }

  /* Return function status */
  return HAL_OK;
 81007b2:	2300      	movs	r3, #0
 81007b4:	e000      	b.n	81007b8 <HAL_InitTick+0x58>
    return HAL_ERROR;
 81007b6:	2301      	movs	r3, #1
}
 81007b8:	4618      	mov	r0, r3
 81007ba:	3708      	adds	r7, #8
 81007bc:	46bd      	mov	sp, r7
 81007be:	bd80      	pop	{r7, pc}
 81007c0:	1000000c 	.word	0x1000000c
 81007c4:	10000000 	.word	0x10000000
 81007c8:	10000008 	.word	0x10000008

081007cc <__NVIC_SetPriorityGrouping>:
           In case of a conflict between priority grouping and available
           priority bits (__NVIC_PRIO_BITS), the smallest possible priority group is set.
  \param [in]      PriorityGroup  Priority grouping field.
 */
__STATIC_INLINE void __NVIC_SetPriorityGrouping(uint32_t PriorityGroup)
{
 81007cc:	b480      	push	{r7}
 81007ce:	b085      	sub	sp, #20
 81007d0:	af00      	add	r7, sp, #0
 81007d2:	6078      	str	r0, [r7, #4]
  uint32_t reg_value;
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);             /* only values 0..7 are used          */
 81007d4:	687b      	ldr	r3, [r7, #4]
 81007d6:	f003 0307 	and.w	r3, r3, #7
 81007da:	60fb      	str	r3, [r7, #12]

  reg_value  =  SCB->AIRCR;                                                   /* read old register configuration    */
 81007dc:	4b0c      	ldr	r3, [pc, #48]	; (8100810 <__NVIC_SetPriorityGrouping+0x44>)
 81007de:	68db      	ldr	r3, [r3, #12]
 81007e0:	60bb      	str	r3, [r7, #8]
  reg_value &= ~((uint32_t)(SCB_AIRCR_VECTKEY_Msk | SCB_AIRCR_PRIGROUP_Msk)); /* clear bits to change               */
 81007e2:	68ba      	ldr	r2, [r7, #8]
 81007e4:	f64f 03ff 	movw	r3, #63743	; 0xf8ff
 81007e8:	4013      	ands	r3, r2
 81007ea:	60bb      	str	r3, [r7, #8]
  reg_value  =  (reg_value                                   |
                ((uint32_t)0x5FAUL << SCB_AIRCR_VECTKEY_Pos) |
                (PriorityGroupTmp << SCB_AIRCR_PRIGROUP_Pos)  );              /* Insert write key and priority group */
 81007ec:	68fb      	ldr	r3, [r7, #12]
 81007ee:	021a      	lsls	r2, r3, #8
                ((uint32_t)0x5FAUL << SCB_AIRCR_VECTKEY_Pos) |
 81007f0:	68bb      	ldr	r3, [r7, #8]
 81007f2:	4313      	orrs	r3, r2
  reg_value  =  (reg_value                                   |
 81007f4:	f043 63bf 	orr.w	r3, r3, #100139008	; 0x5f80000
 81007f8:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
 81007fc:	60bb      	str	r3, [r7, #8]
  SCB->AIRCR =  reg_value;
 81007fe:	4a04      	ldr	r2, [pc, #16]	; (8100810 <__NVIC_SetPriorityGrouping+0x44>)
 8100800:	68bb      	ldr	r3, [r7, #8]
 8100802:	60d3      	str	r3, [r2, #12]
}
 8100804:	bf00      	nop
 8100806:	3714      	adds	r7, #20
 8100808:	46bd      	mov	sp, r7
 810080a:	f85d 7b04 	ldr.w	r7, [sp], #4
 810080e:	4770      	bx	lr
 8100810:	e000ed00 	.word	0xe000ed00

08100814 <__NVIC_GetPriorityGrouping>:
  \brief   Get Priority Grouping
  \details Reads the priority grouping field from the NVIC Interrupt Controller.
  \return                Priority grouping field (SCB->AIRCR [10:8] PRIGROUP field).
 */
__STATIC_INLINE uint32_t __NVIC_GetPriorityGrouping(void)
{
 8100814:	b480      	push	{r7}
 8100816:	af00      	add	r7, sp, #0
  return ((uint32_t)((SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) >> SCB_AIRCR_PRIGROUP_Pos));
 8100818:	4b04      	ldr	r3, [pc, #16]	; (810082c <__NVIC_GetPriorityGrouping+0x18>)
 810081a:	68db      	ldr	r3, [r3, #12]
 810081c:	0a1b      	lsrs	r3, r3, #8
 810081e:	f003 0307 	and.w	r3, r3, #7
}
 8100822:	4618      	mov	r0, r3
 8100824:	46bd      	mov	sp, r7
 8100826:	f85d 7b04 	ldr.w	r7, [sp], #4
 810082a:	4770      	bx	lr
 810082c:	e000ed00 	.word	0xe000ed00

08100830 <__NVIC_SetPriority>:
  \param [in]      IRQn  Interrupt number.
  \param [in]  priority  Priority to set.
  \note    The priority cannot be set for every processor exception.
 */
__STATIC_INLINE void __NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
{
 8100830:	b480      	push	{r7}
 8100832:	b083      	sub	sp, #12
 8100834:	af00      	add	r7, sp, #0
 8100836:	4603      	mov	r3, r0
 8100838:	6039      	str	r1, [r7, #0]
 810083a:	80fb      	strh	r3, [r7, #6]
  if ((int32_t)(IRQn) >= 0)
 810083c:	f9b7 3006 	ldrsh.w	r3, [r7, #6]
 8100840:	2b00      	cmp	r3, #0
 8100842:	db0a      	blt.n	810085a <__NVIC_SetPriority+0x2a>
  {
    NVIC->IP[((uint32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 8100844:	683b      	ldr	r3, [r7, #0]
 8100846:	b2da      	uxtb	r2, r3
 8100848:	490c      	ldr	r1, [pc, #48]	; (810087c <__NVIC_SetPriority+0x4c>)
 810084a:	f9b7 3006 	ldrsh.w	r3, [r7, #6]
 810084e:	0112      	lsls	r2, r2, #4
 8100850:	b2d2      	uxtb	r2, r2
 8100852:	440b      	add	r3, r1
 8100854:	f883 2300 	strb.w	r2, [r3, #768]	; 0x300
  }
  else
  {
    SCB->SHP[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
  }
}
 8100858:	e00a      	b.n	8100870 <__NVIC_SetPriority+0x40>
    SCB->SHP[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 810085a:	683b      	ldr	r3, [r7, #0]
 810085c:	b2da      	uxtb	r2, r3
 810085e:	4908      	ldr	r1, [pc, #32]	; (8100880 <__NVIC_SetPriority+0x50>)
 8100860:	88fb      	ldrh	r3, [r7, #6]
 8100862:	f003 030f 	and.w	r3, r3, #15
 8100866:	3b04      	subs	r3, #4
 8100868:	0112      	lsls	r2, r2, #4
 810086a:	b2d2      	uxtb	r2, r2
 810086c:	440b      	add	r3, r1
 810086e:	761a      	strb	r2, [r3, #24]
}
 8100870:	bf00      	nop
 8100872:	370c      	adds	r7, #12
 8100874:	46bd      	mov	sp, r7
 8100876:	f85d 7b04 	ldr.w	r7, [sp], #4
 810087a:	4770      	bx	lr
 810087c:	e000e100 	.word	0xe000e100
 8100880:	e000ed00 	.word	0xe000ed00

08100884 <NVIC_EncodePriority>:
  \param [in]   PreemptPriority  Preemptive priority value (starting from 0).
  \param [in]       SubPriority  Subpriority value (starting from 0).
  \return                        Encoded priority. Value can be used in the function \ref NVIC_SetPriority().
 */
__STATIC_INLINE uint32_t NVIC_EncodePriority (uint32_t PriorityGroup, uint32_t PreemptPriority, uint32_t SubPriority)
{
 8100884:	b480      	push	{r7}
 8100886:	b089      	sub	sp, #36	; 0x24
 8100888:	af00      	add	r7, sp, #0
 810088a:	60f8      	str	r0, [r7, #12]
 810088c:	60b9      	str	r1, [r7, #8]
 810088e:	607a      	str	r2, [r7, #4]
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);   /* only values 0..7 are used          */
 8100890:	68fb      	ldr	r3, [r7, #12]
 8100892:	f003 0307 	and.w	r3, r3, #7
 8100896:	61fb      	str	r3, [r7, #28]
  uint32_t PreemptPriorityBits;
  uint32_t SubPriorityBits;

  PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(__NVIC_PRIO_BITS)) ? (uint32_t)(__NVIC_PRIO_BITS) : (uint32_t)(7UL - PriorityGroupTmp);
 8100898:	69fb      	ldr	r3, [r7, #28]
 810089a:	f1c3 0307 	rsb	r3, r3, #7
 810089e:	2b04      	cmp	r3, #4
 81008a0:	bf28      	it	cs
 81008a2:	2304      	movcs	r3, #4
 81008a4:	61bb      	str	r3, [r7, #24]
  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));
 81008a6:	69fb      	ldr	r3, [r7, #28]
 81008a8:	3304      	adds	r3, #4
 81008aa:	2b06      	cmp	r3, #6
 81008ac:	d902      	bls.n	81008b4 <NVIC_EncodePriority+0x30>
 81008ae:	69fb      	ldr	r3, [r7, #28]
 81008b0:	3b03      	subs	r3, #3
 81008b2:	e000      	b.n	81008b6 <NVIC_EncodePriority+0x32>
 81008b4:	2300      	movs	r3, #0
 81008b6:	617b      	str	r3, [r7, #20]

  return (
           ((PreemptPriority & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL)) << SubPriorityBits) |
 81008b8:	f04f 32ff 	mov.w	r2, #4294967295
 81008bc:	69bb      	ldr	r3, [r7, #24]
 81008be:	fa02 f303 	lsl.w	r3, r2, r3
 81008c2:	43da      	mvns	r2, r3
 81008c4:	68bb      	ldr	r3, [r7, #8]
 81008c6:	401a      	ands	r2, r3
 81008c8:	697b      	ldr	r3, [r7, #20]
 81008ca:	409a      	lsls	r2, r3
           ((SubPriority     & (uint32_t)((1UL << (SubPriorityBits    )) - 1UL)))
 81008cc:	f04f 31ff 	mov.w	r1, #4294967295
 81008d0:	697b      	ldr	r3, [r7, #20]
 81008d2:	fa01 f303 	lsl.w	r3, r1, r3
 81008d6:	43d9      	mvns	r1, r3
 81008d8:	687b      	ldr	r3, [r7, #4]
 81008da:	400b      	ands	r3, r1
           ((PreemptPriority & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL)) << SubPriorityBits) |
 81008dc:	4313      	orrs	r3, r2
         );
}
 81008de:	4618      	mov	r0, r3
 81008e0:	3724      	adds	r7, #36	; 0x24
 81008e2:	46bd      	mov	sp, r7
 81008e4:	f85d 7b04 	ldr.w	r7, [sp], #4
 81008e8:	4770      	bx	lr
	...

081008ec <SysTick_Config>:
  \note    When the variable <b>__Vendor_SysTickConfig</b> is set to 1, then the
           function <b>SysTick_Config</b> is not included. In this case, the file <b><i>device</i>.h</b>
           must contain a vendor-specific implementation of this function.
 */
__STATIC_INLINE uint32_t SysTick_Config(uint32_t ticks)
{
 81008ec:	b580      	push	{r7, lr}
 81008ee:	b082      	sub	sp, #8
 81008f0:	af00      	add	r7, sp, #0
 81008f2:	6078      	str	r0, [r7, #4]
  if ((ticks - 1UL) > SysTick_LOAD_RELOAD_Msk)
 81008f4:	687b      	ldr	r3, [r7, #4]
 81008f6:	3b01      	subs	r3, #1
 81008f8:	f1b3 7f80 	cmp.w	r3, #16777216	; 0x1000000
 81008fc:	d301      	bcc.n	8100902 <SysTick_Config+0x16>
  {
    return (1UL);                                                   /* Reload value impossible */
 81008fe:	2301      	movs	r3, #1
 8100900:	e00f      	b.n	8100922 <SysTick_Config+0x36>
  }

  SysTick->LOAD  = (uint32_t)(ticks - 1UL);                         /* set reload register */
 8100902:	4a0a      	ldr	r2, [pc, #40]	; (810092c <SysTick_Config+0x40>)
 8100904:	687b      	ldr	r3, [r7, #4]
 8100906:	3b01      	subs	r3, #1
 8100908:	6053      	str	r3, [r2, #4]
  NVIC_SetPriority (SysTick_IRQn, (1UL << __NVIC_PRIO_BITS) - 1UL); /* set Priority for Systick Interrupt */
 810090a:	210f      	movs	r1, #15
 810090c:	f04f 30ff 	mov.w	r0, #4294967295
 8100910:	f7ff ff8e 	bl	8100830 <__NVIC_SetPriority>
  SysTick->VAL   = 0UL;                                             /* Load the SysTick Counter Value */
 8100914:	4b05      	ldr	r3, [pc, #20]	; (810092c <SysTick_Config+0x40>)
 8100916:	2200      	movs	r2, #0
 8100918:	609a      	str	r2, [r3, #8]
  SysTick->CTRL  = SysTick_CTRL_CLKSOURCE_Msk |
 810091a:	4b04      	ldr	r3, [pc, #16]	; (810092c <SysTick_Config+0x40>)
 810091c:	2207      	movs	r2, #7
 810091e:	601a      	str	r2, [r3, #0]
                   SysTick_CTRL_TICKINT_Msk   |
                   SysTick_CTRL_ENABLE_Msk;                         /* Enable SysTick IRQ and SysTick Timer */
  return (0UL);                                                     /* Function successful */
 8100920:	2300      	movs	r3, #0
}
 8100922:	4618      	mov	r0, r3
 8100924:	3708      	adds	r7, #8
 8100926:	46bd      	mov	sp, r7
 8100928:	bd80      	pop	{r7, pc}
 810092a:	bf00      	nop
 810092c:	e000e010 	.word	0xe000e010

08100930 <HAL_NVIC_SetPriorityGrouping>:
  * @note   When the NVIC_PriorityGroup_0 is selected, IRQ preemption is no more possible.
  *         The pending IRQ priority will be managed only by the subpriority.
  * @retval None
  */
void HAL_NVIC_SetPriorityGrouping(uint32_t PriorityGroup)
{
 8100930:	b580      	push	{r7, lr}
 8100932:	b082      	sub	sp, #8
 8100934:	af00      	add	r7, sp, #0
 8100936:	6078      	str	r0, [r7, #4]
  /* Check the parameters */
  assert_param(IS_NVIC_PRIORITY_GROUP(PriorityGroup));

  /* Set the PRIGROUP[10:8] bits according to the PriorityGroup parameter value */
  NVIC_SetPriorityGrouping(PriorityGroup);
 8100938:	6878      	ldr	r0, [r7, #4]
 810093a:	f7ff ff47 	bl	81007cc <__NVIC_SetPriorityGrouping>
}
 810093e:	bf00      	nop
 8100940:	3708      	adds	r7, #8
 8100942:	46bd      	mov	sp, r7
 8100944:	bd80      	pop	{r7, pc}

08100946 <HAL_NVIC_SetPriority>:
  *         This parameter can be a value between 0 and 15
  *         A lower priority value indicates a higher priority.
  * @retval None
  */
void HAL_NVIC_SetPriority(IRQn_Type IRQn, uint32_t PreemptPriority, uint32_t SubPriority)
{
 8100946:	b580      	push	{r7, lr}
 8100948:	b086      	sub	sp, #24
 810094a:	af00      	add	r7, sp, #0
 810094c:	4603      	mov	r3, r0
 810094e:	60b9      	str	r1, [r7, #8]
 8100950:	607a      	str	r2, [r7, #4]
 8100952:	81fb      	strh	r3, [r7, #14]

  /* Check the parameters */
  assert_param(IS_NVIC_SUB_PRIORITY(SubPriority));
  assert_param(IS_NVIC_PREEMPTION_PRIORITY(PreemptPriority));

  prioritygroup = NVIC_GetPriorityGrouping();
 8100954:	f7ff ff5e 	bl	8100814 <__NVIC_GetPriorityGrouping>
 8100958:	6178      	str	r0, [r7, #20]

  NVIC_SetPriority(IRQn, NVIC_EncodePriority(prioritygroup, PreemptPriority, SubPriority));
 810095a:	687a      	ldr	r2, [r7, #4]
 810095c:	68b9      	ldr	r1, [r7, #8]
 810095e:	6978      	ldr	r0, [r7, #20]
 8100960:	f7ff ff90 	bl	8100884 <NVIC_EncodePriority>
 8100964:	4602      	mov	r2, r0
 8100966:	f9b7 300e 	ldrsh.w	r3, [r7, #14]
 810096a:	4611      	mov	r1, r2
 810096c:	4618      	mov	r0, r3
 810096e:	f7ff ff5f 	bl	8100830 <__NVIC_SetPriority>
}
 8100972:	bf00      	nop
 8100974:	3718      	adds	r7, #24
 8100976:	46bd      	mov	sp, r7
 8100978:	bd80      	pop	{r7, pc}

0810097a <HAL_SYSTICK_Config>:
  * @param  TicksNumb Specifies the ticks Number of ticks between two interrupts.
  * @retval status   - 0  Function succeeded.
  *                  - 1  Function failed.
  */
uint32_t HAL_SYSTICK_Config(uint32_t TicksNumb)
{
 810097a:	b580      	push	{r7, lr}
 810097c:	b082      	sub	sp, #8
 810097e:	af00      	add	r7, sp, #0
 8100980:	6078      	str	r0, [r7, #4]
   return SysTick_Config(TicksNumb);
 8100982:	6878      	ldr	r0, [r7, #4]
 8100984:	f7ff ffb2 	bl	81008ec <SysTick_Config>
 8100988:	4603      	mov	r3, r0
}
 810098a:	4618      	mov	r0, r3
 810098c:	3708      	adds	r7, #8
 810098e:	46bd      	mov	sp, r7
 8100990:	bd80      	pop	{r7, pc}
	...

08100994 <HAL_GetCurrentCPUID>:
/**
  * @brief  Returns the current CPU ID.
  * @retval CPU identifier
  */
uint32_t HAL_GetCurrentCPUID(void)
{
 8100994:	b480      	push	{r7}
 8100996:	af00      	add	r7, sp, #0
  if (((SCB->CPUID & 0x000000F0U) >> 4 )== 0x7U)
 8100998:	4b07      	ldr	r3, [pc, #28]	; (81009b8 <HAL_GetCurrentCPUID+0x24>)
 810099a:	681b      	ldr	r3, [r3, #0]
 810099c:	091b      	lsrs	r3, r3, #4
 810099e:	f003 030f 	and.w	r3, r3, #15
 81009a2:	2b07      	cmp	r3, #7
 81009a4:	d101      	bne.n	81009aa <HAL_GetCurrentCPUID+0x16>
  {
    return  CM7_CPUID;
 81009a6:	2303      	movs	r3, #3
 81009a8:	e000      	b.n	81009ac <HAL_GetCurrentCPUID+0x18>
  }
  else
  {
    return CM4_CPUID;
 81009aa:	2301      	movs	r3, #1
  }
}
 81009ac:	4618      	mov	r0, r3
 81009ae:	46bd      	mov	sp, r7
 81009b0:	f85d 7b04 	ldr.w	r7, [sp], #4
 81009b4:	4770      	bx	lr
 81009b6:	bf00      	nop
 81009b8:	e000ed00 	.word	0xe000ed00

081009bc <HAL_GPIO_Init>:
  * @param  GPIO_Init: pointer to a GPIO_InitTypeDef structure that contains
  *         the configuration information for the specified GPIO peripheral.
  * @retval None
  */
void HAL_GPIO_Init(GPIO_TypeDef  *GPIOx, GPIO_InitTypeDef *GPIO_Init)
{
 81009bc:	b480      	push	{r7}
 81009be:	b089      	sub	sp, #36	; 0x24
 81009c0:	af00      	add	r7, sp, #0
 81009c2:	6078      	str	r0, [r7, #4]
 81009c4:	6039      	str	r1, [r7, #0]
  uint32_t position = 0x00U;
 81009c6:	2300      	movs	r3, #0
 81009c8:	61fb      	str	r3, [r7, #28]
  uint32_t iocurrent;
  uint32_t temp;
  EXTI_Core_TypeDef *EXTI_CurrentCPU;

#if defined(DUAL_CORE) && defined(CORE_CM4)
  EXTI_CurrentCPU = EXTI_D2; /* EXTI for CM4 CPU */
 81009ca:	4b89      	ldr	r3, [pc, #548]	; (8100bf0 <HAL_GPIO_Init+0x234>)
 81009cc:	617b      	str	r3, [r7, #20]
  assert_param(IS_GPIO_ALL_INSTANCE(GPIOx));
  assert_param(IS_GPIO_PIN(GPIO_Init->Pin));
  assert_param(IS_GPIO_MODE(GPIO_Init->Mode));

  /* Configure the port pins */
  while (((GPIO_Init->Pin) >> position) != 0x00U)
 81009ce:	e194      	b.n	8100cfa <HAL_GPIO_Init+0x33e>
  {
    /* Get current io position */
    iocurrent = (GPIO_Init->Pin) & (1UL << position);
 81009d0:	683b      	ldr	r3, [r7, #0]
 81009d2:	681a      	ldr	r2, [r3, #0]
 81009d4:	2101      	movs	r1, #1
 81009d6:	69fb      	ldr	r3, [r7, #28]
 81009d8:	fa01 f303 	lsl.w	r3, r1, r3
 81009dc:	4013      	ands	r3, r2
 81009de:	613b      	str	r3, [r7, #16]

    if (iocurrent != 0x00U)
 81009e0:	693b      	ldr	r3, [r7, #16]
 81009e2:	2b00      	cmp	r3, #0
 81009e4:	f000 8186 	beq.w	8100cf4 <HAL_GPIO_Init+0x338>
    {
      /*--------------------- GPIO Mode Configuration ------------------------*/
      /* In case of Output or Alternate function mode selection */
      if (((GPIO_Init->Mode & GPIO_MODE) == MODE_OUTPUT) || ((GPIO_Init->Mode & GPIO_MODE) == MODE_AF))
 81009e8:	683b      	ldr	r3, [r7, #0]
 81009ea:	685b      	ldr	r3, [r3, #4]
 81009ec:	f003 0303 	and.w	r3, r3, #3
 81009f0:	2b01      	cmp	r3, #1
 81009f2:	d005      	beq.n	8100a00 <HAL_GPIO_Init+0x44>
 81009f4:	683b      	ldr	r3, [r7, #0]
 81009f6:	685b      	ldr	r3, [r3, #4]
 81009f8:	f003 0303 	and.w	r3, r3, #3
 81009fc:	2b02      	cmp	r3, #2
 81009fe:	d130      	bne.n	8100a62 <HAL_GPIO_Init+0xa6>
      {
        /* Check the Speed parameter */
        assert_param(IS_GPIO_SPEED(GPIO_Init->Speed));

        /* Configure the IO Speed */
        temp = GPIOx->OSPEEDR;
 8100a00:	687b      	ldr	r3, [r7, #4]
 8100a02:	689b      	ldr	r3, [r3, #8]
 8100a04:	61bb      	str	r3, [r7, #24]
        temp &= ~(GPIO_OSPEEDR_OSPEED0 << (position * 2U));
 8100a06:	69fb      	ldr	r3, [r7, #28]
 8100a08:	005b      	lsls	r3, r3, #1
 8100a0a:	2203      	movs	r2, #3
 8100a0c:	fa02 f303 	lsl.w	r3, r2, r3
 8100a10:	43db      	mvns	r3, r3
 8100a12:	69ba      	ldr	r2, [r7, #24]
 8100a14:	4013      	ands	r3, r2
 8100a16:	61bb      	str	r3, [r7, #24]
        temp |= (GPIO_Init->Speed << (position * 2U));
 8100a18:	683b      	ldr	r3, [r7, #0]
 8100a1a:	68da      	ldr	r2, [r3, #12]
 8100a1c:	69fb      	ldr	r3, [r7, #28]
 8100a1e:	005b      	lsls	r3, r3, #1
 8100a20:	fa02 f303 	lsl.w	r3, r2, r3
 8100a24:	69ba      	ldr	r2, [r7, #24]
 8100a26:	4313      	orrs	r3, r2
 8100a28:	61bb      	str	r3, [r7, #24]
        GPIOx->OSPEEDR = temp;
 8100a2a:	687b      	ldr	r3, [r7, #4]
 8100a2c:	69ba      	ldr	r2, [r7, #24]
 8100a2e:	609a      	str	r2, [r3, #8]

        /* Configure the IO Output Type */
        temp = GPIOx->OTYPER;
 8100a30:	687b      	ldr	r3, [r7, #4]
 8100a32:	685b      	ldr	r3, [r3, #4]
 8100a34:	61bb      	str	r3, [r7, #24]
        temp &= ~(GPIO_OTYPER_OT0 << position) ;
 8100a36:	2201      	movs	r2, #1
 8100a38:	69fb      	ldr	r3, [r7, #28]
 8100a3a:	fa02 f303 	lsl.w	r3, r2, r3
 8100a3e:	43db      	mvns	r3, r3
 8100a40:	69ba      	ldr	r2, [r7, #24]
 8100a42:	4013      	ands	r3, r2
 8100a44:	61bb      	str	r3, [r7, #24]
        temp |= (((GPIO_Init->Mode & OUTPUT_TYPE) >> OUTPUT_TYPE_Pos) << position);
 8100a46:	683b      	ldr	r3, [r7, #0]
 8100a48:	685b      	ldr	r3, [r3, #4]
 8100a4a:	091b      	lsrs	r3, r3, #4
 8100a4c:	f003 0201 	and.w	r2, r3, #1
 8100a50:	69fb      	ldr	r3, [r7, #28]
 8100a52:	fa02 f303 	lsl.w	r3, r2, r3
 8100a56:	69ba      	ldr	r2, [r7, #24]
 8100a58:	4313      	orrs	r3, r2
 8100a5a:	61bb      	str	r3, [r7, #24]
        GPIOx->OTYPER = temp;
 8100a5c:	687b      	ldr	r3, [r7, #4]
 8100a5e:	69ba      	ldr	r2, [r7, #24]
 8100a60:	605a      	str	r2, [r3, #4]
      }

      if ((GPIO_Init->Mode & GPIO_MODE) != MODE_ANALOG)
 8100a62:	683b      	ldr	r3, [r7, #0]
 8100a64:	685b      	ldr	r3, [r3, #4]
 8100a66:	f003 0303 	and.w	r3, r3, #3
 8100a6a:	2b03      	cmp	r3, #3
 8100a6c:	d017      	beq.n	8100a9e <HAL_GPIO_Init+0xe2>
      {
       /* Check the Pull parameter */
       assert_param(IS_GPIO_PULL(GPIO_Init->Pull));

      /* Activate the Pull-up or Pull down resistor for the current IO */
      temp = GPIOx->PUPDR;
 8100a6e:	687b      	ldr	r3, [r7, #4]
 8100a70:	68db      	ldr	r3, [r3, #12]
 8100a72:	61bb      	str	r3, [r7, #24]
      temp &= ~(GPIO_PUPDR_PUPD0 << (position * 2U));
 8100a74:	69fb      	ldr	r3, [r7, #28]
 8100a76:	005b      	lsls	r3, r3, #1
 8100a78:	2203      	movs	r2, #3
 8100a7a:	fa02 f303 	lsl.w	r3, r2, r3
 8100a7e:	43db      	mvns	r3, r3
 8100a80:	69ba      	ldr	r2, [r7, #24]
 8100a82:	4013      	ands	r3, r2
 8100a84:	61bb      	str	r3, [r7, #24]
      temp |= ((GPIO_Init->Pull) << (position * 2U));
 8100a86:	683b      	ldr	r3, [r7, #0]
 8100a88:	689a      	ldr	r2, [r3, #8]
 8100a8a:	69fb      	ldr	r3, [r7, #28]
 8100a8c:	005b      	lsls	r3, r3, #1
 8100a8e:	fa02 f303 	lsl.w	r3, r2, r3
 8100a92:	69ba      	ldr	r2, [r7, #24]
 8100a94:	4313      	orrs	r3, r2
 8100a96:	61bb      	str	r3, [r7, #24]
      GPIOx->PUPDR = temp;
 8100a98:	687b      	ldr	r3, [r7, #4]
 8100a9a:	69ba      	ldr	r2, [r7, #24]
 8100a9c:	60da      	str	r2, [r3, #12]
      }

      /* In case of Alternate function mode selection */
      if ((GPIO_Init->Mode & GPIO_MODE) == MODE_AF)
 8100a9e:	683b      	ldr	r3, [r7, #0]
 8100aa0:	685b      	ldr	r3, [r3, #4]
 8100aa2:	f003 0303 	and.w	r3, r3, #3
 8100aa6:	2b02      	cmp	r3, #2
 8100aa8:	d123      	bne.n	8100af2 <HAL_GPIO_Init+0x136>
        /* Check the Alternate function parameters */
        assert_param(IS_GPIO_AF_INSTANCE(GPIOx));
        assert_param(IS_GPIO_AF(GPIO_Init->Alternate));

        /* Configure Alternate function mapped with the current IO */
        temp = GPIOx->AFR[position >> 3U];
 8100aaa:	69fb      	ldr	r3, [r7, #28]
 8100aac:	08da      	lsrs	r2, r3, #3
 8100aae:	687b      	ldr	r3, [r7, #4]
 8100ab0:	3208      	adds	r2, #8
 8100ab2:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 8100ab6:	61bb      	str	r3, [r7, #24]
        temp &= ~(0xFU << ((position & 0x07U) * 4U));
 8100ab8:	69fb      	ldr	r3, [r7, #28]
 8100aba:	f003 0307 	and.w	r3, r3, #7
 8100abe:	009b      	lsls	r3, r3, #2
 8100ac0:	220f      	movs	r2, #15
 8100ac2:	fa02 f303 	lsl.w	r3, r2, r3
 8100ac6:	43db      	mvns	r3, r3
 8100ac8:	69ba      	ldr	r2, [r7, #24]
 8100aca:	4013      	ands	r3, r2
 8100acc:	61bb      	str	r3, [r7, #24]
        temp |= ((GPIO_Init->Alternate) << ((position & 0x07U) * 4U));
 8100ace:	683b      	ldr	r3, [r7, #0]
 8100ad0:	691a      	ldr	r2, [r3, #16]
 8100ad2:	69fb      	ldr	r3, [r7, #28]
 8100ad4:	f003 0307 	and.w	r3, r3, #7
 8100ad8:	009b      	lsls	r3, r3, #2
 8100ada:	fa02 f303 	lsl.w	r3, r2, r3
 8100ade:	69ba      	ldr	r2, [r7, #24]
 8100ae0:	4313      	orrs	r3, r2
 8100ae2:	61bb      	str	r3, [r7, #24]
        GPIOx->AFR[position >> 3U] = temp;
 8100ae4:	69fb      	ldr	r3, [r7, #28]
 8100ae6:	08da      	lsrs	r2, r3, #3
 8100ae8:	687b      	ldr	r3, [r7, #4]
 8100aea:	3208      	adds	r2, #8
 8100aec:	69b9      	ldr	r1, [r7, #24]
 8100aee:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
      }

      /* Configure IO Direction mode (Input, Output, Alternate or Analog) */
      temp = GPIOx->MODER;
 8100af2:	687b      	ldr	r3, [r7, #4]
 8100af4:	681b      	ldr	r3, [r3, #0]
 8100af6:	61bb      	str	r3, [r7, #24]
      temp &= ~(GPIO_MODER_MODE0 << (position * 2U));
 8100af8:	69fb      	ldr	r3, [r7, #28]
 8100afa:	005b      	lsls	r3, r3, #1
 8100afc:	2203      	movs	r2, #3
 8100afe:	fa02 f303 	lsl.w	r3, r2, r3
 8100b02:	43db      	mvns	r3, r3
 8100b04:	69ba      	ldr	r2, [r7, #24]
 8100b06:	4013      	ands	r3, r2
 8100b08:	61bb      	str	r3, [r7, #24]
      temp |= ((GPIO_Init->Mode & GPIO_MODE) << (position * 2U));
 8100b0a:	683b      	ldr	r3, [r7, #0]
 8100b0c:	685b      	ldr	r3, [r3, #4]
 8100b0e:	f003 0203 	and.w	r2, r3, #3
 8100b12:	69fb      	ldr	r3, [r7, #28]
 8100b14:	005b      	lsls	r3, r3, #1
 8100b16:	fa02 f303 	lsl.w	r3, r2, r3
 8100b1a:	69ba      	ldr	r2, [r7, #24]
 8100b1c:	4313      	orrs	r3, r2
 8100b1e:	61bb      	str	r3, [r7, #24]
      GPIOx->MODER = temp;
 8100b20:	687b      	ldr	r3, [r7, #4]
 8100b22:	69ba      	ldr	r2, [r7, #24]
 8100b24:	601a      	str	r2, [r3, #0]

      /*--------------------- EXTI Mode Configuration ------------------------*/
      /* Configure the External Interrupt or event for the current IO */
      if ((GPIO_Init->Mode & EXTI_MODE) != 0x00U)
 8100b26:	683b      	ldr	r3, [r7, #0]
 8100b28:	685b      	ldr	r3, [r3, #4]
 8100b2a:	f403 3340 	and.w	r3, r3, #196608	; 0x30000
 8100b2e:	2b00      	cmp	r3, #0
 8100b30:	f000 80e0 	beq.w	8100cf4 <HAL_GPIO_Init+0x338>
      {
        /* Enable SYSCFG Clock */
        __HAL_RCC_SYSCFG_CLK_ENABLE();
 8100b34:	4b2f      	ldr	r3, [pc, #188]	; (8100bf4 <HAL_GPIO_Init+0x238>)
 8100b36:	f8d3 30f4 	ldr.w	r3, [r3, #244]	; 0xf4
 8100b3a:	4a2e      	ldr	r2, [pc, #184]	; (8100bf4 <HAL_GPIO_Init+0x238>)
 8100b3c:	f043 0302 	orr.w	r3, r3, #2
 8100b40:	f8c2 30f4 	str.w	r3, [r2, #244]	; 0xf4
 8100b44:	4b2b      	ldr	r3, [pc, #172]	; (8100bf4 <HAL_GPIO_Init+0x238>)
 8100b46:	f8d3 30f4 	ldr.w	r3, [r3, #244]	; 0xf4
 8100b4a:	f003 0302 	and.w	r3, r3, #2
 8100b4e:	60fb      	str	r3, [r7, #12]
 8100b50:	68fb      	ldr	r3, [r7, #12]

        temp = SYSCFG->EXTICR[position >> 2U];
 8100b52:	4a29      	ldr	r2, [pc, #164]	; (8100bf8 <HAL_GPIO_Init+0x23c>)
 8100b54:	69fb      	ldr	r3, [r7, #28]
 8100b56:	089b      	lsrs	r3, r3, #2
 8100b58:	3302      	adds	r3, #2
 8100b5a:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 8100b5e:	61bb      	str	r3, [r7, #24]
        temp &= ~(0x0FUL << (4U * (position & 0x03U)));
 8100b60:	69fb      	ldr	r3, [r7, #28]
 8100b62:	f003 0303 	and.w	r3, r3, #3
 8100b66:	009b      	lsls	r3, r3, #2
 8100b68:	220f      	movs	r2, #15
 8100b6a:	fa02 f303 	lsl.w	r3, r2, r3
 8100b6e:	43db      	mvns	r3, r3
 8100b70:	69ba      	ldr	r2, [r7, #24]
 8100b72:	4013      	ands	r3, r2
 8100b74:	61bb      	str	r3, [r7, #24]
        temp |= (GPIO_GET_INDEX(GPIOx) << (4U * (position & 0x03U)));
 8100b76:	687b      	ldr	r3, [r7, #4]
 8100b78:	4a20      	ldr	r2, [pc, #128]	; (8100bfc <HAL_GPIO_Init+0x240>)
 8100b7a:	4293      	cmp	r3, r2
 8100b7c:	d052      	beq.n	8100c24 <HAL_GPIO_Init+0x268>
 8100b7e:	687b      	ldr	r3, [r7, #4]
 8100b80:	4a1f      	ldr	r2, [pc, #124]	; (8100c00 <HAL_GPIO_Init+0x244>)
 8100b82:	4293      	cmp	r3, r2
 8100b84:	d031      	beq.n	8100bea <HAL_GPIO_Init+0x22e>
 8100b86:	687b      	ldr	r3, [r7, #4]
 8100b88:	4a1e      	ldr	r2, [pc, #120]	; (8100c04 <HAL_GPIO_Init+0x248>)
 8100b8a:	4293      	cmp	r3, r2
 8100b8c:	d02b      	beq.n	8100be6 <HAL_GPIO_Init+0x22a>
 8100b8e:	687b      	ldr	r3, [r7, #4]
 8100b90:	4a1d      	ldr	r2, [pc, #116]	; (8100c08 <HAL_GPIO_Init+0x24c>)
 8100b92:	4293      	cmp	r3, r2
 8100b94:	d025      	beq.n	8100be2 <HAL_GPIO_Init+0x226>
 8100b96:	687b      	ldr	r3, [r7, #4]
 8100b98:	4a1c      	ldr	r2, [pc, #112]	; (8100c0c <HAL_GPIO_Init+0x250>)
 8100b9a:	4293      	cmp	r3, r2
 8100b9c:	d01f      	beq.n	8100bde <HAL_GPIO_Init+0x222>
 8100b9e:	687b      	ldr	r3, [r7, #4]
 8100ba0:	4a1b      	ldr	r2, [pc, #108]	; (8100c10 <HAL_GPIO_Init+0x254>)
 8100ba2:	4293      	cmp	r3, r2
 8100ba4:	d019      	beq.n	8100bda <HAL_GPIO_Init+0x21e>
 8100ba6:	687b      	ldr	r3, [r7, #4]
 8100ba8:	4a1a      	ldr	r2, [pc, #104]	; (8100c14 <HAL_GPIO_Init+0x258>)
 8100baa:	4293      	cmp	r3, r2
 8100bac:	d013      	beq.n	8100bd6 <HAL_GPIO_Init+0x21a>
 8100bae:	687b      	ldr	r3, [r7, #4]
 8100bb0:	4a19      	ldr	r2, [pc, #100]	; (8100c18 <HAL_GPIO_Init+0x25c>)
 8100bb2:	4293      	cmp	r3, r2
 8100bb4:	d00d      	beq.n	8100bd2 <HAL_GPIO_Init+0x216>
 8100bb6:	687b      	ldr	r3, [r7, #4]
 8100bb8:	4a18      	ldr	r2, [pc, #96]	; (8100c1c <HAL_GPIO_Init+0x260>)
 8100bba:	4293      	cmp	r3, r2
 8100bbc:	d007      	beq.n	8100bce <HAL_GPIO_Init+0x212>
 8100bbe:	687b      	ldr	r3, [r7, #4]
 8100bc0:	4a17      	ldr	r2, [pc, #92]	; (8100c20 <HAL_GPIO_Init+0x264>)
 8100bc2:	4293      	cmp	r3, r2
 8100bc4:	d101      	bne.n	8100bca <HAL_GPIO_Init+0x20e>
 8100bc6:	2309      	movs	r3, #9
 8100bc8:	e02d      	b.n	8100c26 <HAL_GPIO_Init+0x26a>
 8100bca:	230a      	movs	r3, #10
 8100bcc:	e02b      	b.n	8100c26 <HAL_GPIO_Init+0x26a>
 8100bce:	2308      	movs	r3, #8
 8100bd0:	e029      	b.n	8100c26 <HAL_GPIO_Init+0x26a>
 8100bd2:	2307      	movs	r3, #7
 8100bd4:	e027      	b.n	8100c26 <HAL_GPIO_Init+0x26a>
 8100bd6:	2306      	movs	r3, #6
 8100bd8:	e025      	b.n	8100c26 <HAL_GPIO_Init+0x26a>
 8100bda:	2305      	movs	r3, #5
 8100bdc:	e023      	b.n	8100c26 <HAL_GPIO_Init+0x26a>
 8100bde:	2304      	movs	r3, #4
 8100be0:	e021      	b.n	8100c26 <HAL_GPIO_Init+0x26a>
 8100be2:	2303      	movs	r3, #3
 8100be4:	e01f      	b.n	8100c26 <HAL_GPIO_Init+0x26a>
 8100be6:	2302      	movs	r3, #2
 8100be8:	e01d      	b.n	8100c26 <HAL_GPIO_Init+0x26a>
 8100bea:	2301      	movs	r3, #1
 8100bec:	e01b      	b.n	8100c26 <HAL_GPIO_Init+0x26a>
 8100bee:	bf00      	nop
 8100bf0:	580000c0 	.word	0x580000c0
 8100bf4:	58024400 	.word	0x58024400
 8100bf8:	58000400 	.word	0x58000400
 8100bfc:	58020000 	.word	0x58020000
 8100c00:	58020400 	.word	0x58020400
 8100c04:	58020800 	.word	0x58020800
 8100c08:	58020c00 	.word	0x58020c00
 8100c0c:	58021000 	.word	0x58021000
 8100c10:	58021400 	.word	0x58021400
 8100c14:	58021800 	.word	0x58021800
 8100c18:	58021c00 	.word	0x58021c00
 8100c1c:	58022000 	.word	0x58022000
 8100c20:	58022400 	.word	0x58022400
 8100c24:	2300      	movs	r3, #0
 8100c26:	69fa      	ldr	r2, [r7, #28]
 8100c28:	f002 0203 	and.w	r2, r2, #3
 8100c2c:	0092      	lsls	r2, r2, #2
 8100c2e:	4093      	lsls	r3, r2
 8100c30:	69ba      	ldr	r2, [r7, #24]
 8100c32:	4313      	orrs	r3, r2
 8100c34:	61bb      	str	r3, [r7, #24]
        SYSCFG->EXTICR[position >> 2U] = temp;
 8100c36:	4938      	ldr	r1, [pc, #224]	; (8100d18 <HAL_GPIO_Init+0x35c>)
 8100c38:	69fb      	ldr	r3, [r7, #28]
 8100c3a:	089b      	lsrs	r3, r3, #2
 8100c3c:	3302      	adds	r3, #2
 8100c3e:	69ba      	ldr	r2, [r7, #24]
 8100c40:	f841 2023 	str.w	r2, [r1, r3, lsl #2]

        /* Clear Rising Falling edge configuration */
        temp = EXTI->RTSR1;
 8100c44:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 8100c48:	681b      	ldr	r3, [r3, #0]
 8100c4a:	61bb      	str	r3, [r7, #24]
        temp &= ~(iocurrent);
 8100c4c:	693b      	ldr	r3, [r7, #16]
 8100c4e:	43db      	mvns	r3, r3
 8100c50:	69ba      	ldr	r2, [r7, #24]
 8100c52:	4013      	ands	r3, r2
 8100c54:	61bb      	str	r3, [r7, #24]
        if ((GPIO_Init->Mode & TRIGGER_RISING) != 0x00U)
 8100c56:	683b      	ldr	r3, [r7, #0]
 8100c58:	685b      	ldr	r3, [r3, #4]
 8100c5a:	f403 1380 	and.w	r3, r3, #1048576	; 0x100000
 8100c5e:	2b00      	cmp	r3, #0
 8100c60:	d003      	beq.n	8100c6a <HAL_GPIO_Init+0x2ae>
        {
          temp |= iocurrent;
 8100c62:	69ba      	ldr	r2, [r7, #24]
 8100c64:	693b      	ldr	r3, [r7, #16]
 8100c66:	4313      	orrs	r3, r2
 8100c68:	61bb      	str	r3, [r7, #24]
        }
        EXTI->RTSR1 = temp;
 8100c6a:	f04f 42b0 	mov.w	r2, #1476395008	; 0x58000000
 8100c6e:	69bb      	ldr	r3, [r7, #24]
 8100c70:	6013      	str	r3, [r2, #0]

        temp = EXTI->FTSR1;
 8100c72:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 8100c76:	685b      	ldr	r3, [r3, #4]
 8100c78:	61bb      	str	r3, [r7, #24]
        temp &= ~(iocurrent);
 8100c7a:	693b      	ldr	r3, [r7, #16]
 8100c7c:	43db      	mvns	r3, r3
 8100c7e:	69ba      	ldr	r2, [r7, #24]
 8100c80:	4013      	ands	r3, r2
 8100c82:	61bb      	str	r3, [r7, #24]
        if ((GPIO_Init->Mode & TRIGGER_FALLING) != 0x00U)
 8100c84:	683b      	ldr	r3, [r7, #0]
 8100c86:	685b      	ldr	r3, [r3, #4]
 8100c88:	f403 1300 	and.w	r3, r3, #2097152	; 0x200000
 8100c8c:	2b00      	cmp	r3, #0
 8100c8e:	d003      	beq.n	8100c98 <HAL_GPIO_Init+0x2dc>
        {
          temp |= iocurrent;
 8100c90:	69ba      	ldr	r2, [r7, #24]
 8100c92:	693b      	ldr	r3, [r7, #16]
 8100c94:	4313      	orrs	r3, r2
 8100c96:	61bb      	str	r3, [r7, #24]
        }
        EXTI->FTSR1 = temp;
 8100c98:	f04f 42b0 	mov.w	r2, #1476395008	; 0x58000000
 8100c9c:	69bb      	ldr	r3, [r7, #24]
 8100c9e:	6053      	str	r3, [r2, #4]

        temp = EXTI_CurrentCPU->EMR1;
 8100ca0:	697b      	ldr	r3, [r7, #20]
 8100ca2:	685b      	ldr	r3, [r3, #4]
 8100ca4:	61bb      	str	r3, [r7, #24]
        temp &= ~(iocurrent);
 8100ca6:	693b      	ldr	r3, [r7, #16]
 8100ca8:	43db      	mvns	r3, r3
 8100caa:	69ba      	ldr	r2, [r7, #24]
 8100cac:	4013      	ands	r3, r2
 8100cae:	61bb      	str	r3, [r7, #24]
        if ((GPIO_Init->Mode & EXTI_EVT) != 0x00U)
 8100cb0:	683b      	ldr	r3, [r7, #0]
 8100cb2:	685b      	ldr	r3, [r3, #4]
 8100cb4:	f403 3300 	and.w	r3, r3, #131072	; 0x20000
 8100cb8:	2b00      	cmp	r3, #0
 8100cba:	d003      	beq.n	8100cc4 <HAL_GPIO_Init+0x308>
        {
          temp |= iocurrent;
 8100cbc:	69ba      	ldr	r2, [r7, #24]
 8100cbe:	693b      	ldr	r3, [r7, #16]
 8100cc0:	4313      	orrs	r3, r2
 8100cc2:	61bb      	str	r3, [r7, #24]
        }
        EXTI_CurrentCPU->EMR1 = temp;
 8100cc4:	697b      	ldr	r3, [r7, #20]
 8100cc6:	69ba      	ldr	r2, [r7, #24]
 8100cc8:	605a      	str	r2, [r3, #4]

        /* Clear EXTI line configuration */
        temp = EXTI_CurrentCPU->IMR1;
 8100cca:	697b      	ldr	r3, [r7, #20]
 8100ccc:	681b      	ldr	r3, [r3, #0]
 8100cce:	61bb      	str	r3, [r7, #24]
        temp &= ~(iocurrent);
 8100cd0:	693b      	ldr	r3, [r7, #16]
 8100cd2:	43db      	mvns	r3, r3
 8100cd4:	69ba      	ldr	r2, [r7, #24]
 8100cd6:	4013      	ands	r3, r2
 8100cd8:	61bb      	str	r3, [r7, #24]
        if ((GPIO_Init->Mode & EXTI_IT) != 0x00U)
 8100cda:	683b      	ldr	r3, [r7, #0]
 8100cdc:	685b      	ldr	r3, [r3, #4]
 8100cde:	f403 3380 	and.w	r3, r3, #65536	; 0x10000
 8100ce2:	2b00      	cmp	r3, #0
 8100ce4:	d003      	beq.n	8100cee <HAL_GPIO_Init+0x332>
        {
          temp |= iocurrent;
 8100ce6:	69ba      	ldr	r2, [r7, #24]
 8100ce8:	693b      	ldr	r3, [r7, #16]
 8100cea:	4313      	orrs	r3, r2
 8100cec:	61bb      	str	r3, [r7, #24]
        }
        EXTI_CurrentCPU->IMR1 = temp;
 8100cee:	697b      	ldr	r3, [r7, #20]
 8100cf0:	69ba      	ldr	r2, [r7, #24]
 8100cf2:	601a      	str	r2, [r3, #0]
      }
    }

    position++;
 8100cf4:	69fb      	ldr	r3, [r7, #28]
 8100cf6:	3301      	adds	r3, #1
 8100cf8:	61fb      	str	r3, [r7, #28]
  while (((GPIO_Init->Pin) >> position) != 0x00U)
 8100cfa:	683b      	ldr	r3, [r7, #0]
 8100cfc:	681a      	ldr	r2, [r3, #0]
 8100cfe:	69fb      	ldr	r3, [r7, #28]
 8100d00:	fa22 f303 	lsr.w	r3, r2, r3
 8100d04:	2b00      	cmp	r3, #0
 8100d06:	f47f ae63 	bne.w	81009d0 <HAL_GPIO_Init+0x14>
  }
}
 8100d0a:	bf00      	nop
 8100d0c:	bf00      	nop
 8100d0e:	3724      	adds	r7, #36	; 0x24
 8100d10:	46bd      	mov	sp, r7
 8100d12:	f85d 7b04 	ldr.w	r7, [sp], #4
 8100d16:	4770      	bx	lr
 8100d18:	58000400 	.word	0x58000400

08100d1c <HAL_GPIO_WritePin>:
  *            @arg GPIO_PIN_RESET: to clear the port pin
  *            @arg GPIO_PIN_SET: to set the port pin
  * @retval None
  */
void HAL_GPIO_WritePin(GPIO_TypeDef *GPIOx, uint16_t GPIO_Pin, GPIO_PinState PinState)
{
 8100d1c:	b480      	push	{r7}
 8100d1e:	b083      	sub	sp, #12
 8100d20:	af00      	add	r7, sp, #0
 8100d22:	6078      	str	r0, [r7, #4]
 8100d24:	460b      	mov	r3, r1
 8100d26:	807b      	strh	r3, [r7, #2]
 8100d28:	4613      	mov	r3, r2
 8100d2a:	707b      	strb	r3, [r7, #1]
  /* Check the parameters */
  assert_param(IS_GPIO_PIN(GPIO_Pin));
  assert_param(IS_GPIO_PIN_ACTION(PinState));

  if (PinState != GPIO_PIN_RESET)
 8100d2c:	787b      	ldrb	r3, [r7, #1]
 8100d2e:	2b00      	cmp	r3, #0
 8100d30:	d003      	beq.n	8100d3a <HAL_GPIO_WritePin+0x1e>
  {
    GPIOx->BSRR = GPIO_Pin;
 8100d32:	887a      	ldrh	r2, [r7, #2]
 8100d34:	687b      	ldr	r3, [r7, #4]
 8100d36:	619a      	str	r2, [r3, #24]
  }
  else
  {
    GPIOx->BSRR = (uint32_t)GPIO_Pin << GPIO_NUMBER;
  }
}
 8100d38:	e003      	b.n	8100d42 <HAL_GPIO_WritePin+0x26>
    GPIOx->BSRR = (uint32_t)GPIO_Pin << GPIO_NUMBER;
 8100d3a:	887b      	ldrh	r3, [r7, #2]
 8100d3c:	041a      	lsls	r2, r3, #16
 8100d3e:	687b      	ldr	r3, [r7, #4]
 8100d40:	619a      	str	r2, [r3, #24]
}
 8100d42:	bf00      	nop
 8100d44:	370c      	adds	r7, #12
 8100d46:	46bd      	mov	sp, r7
 8100d48:	f85d 7b04 	ldr.w	r7, [sp], #4
 8100d4c:	4770      	bx	lr
	...

08100d50 <HAL_HSEM_ActivateNotification>:
  * @brief  Activate Semaphore release Notification for a given Semaphores Mask .
  * @param  SemMask: Mask of Released semaphores
  * @retval Semaphore Key
  */
void HAL_HSEM_ActivateNotification(uint32_t SemMask)
{
 8100d50:	b480      	push	{r7}
 8100d52:	b083      	sub	sp, #12
 8100d54:	af00      	add	r7, sp, #0
 8100d56:	6078      	str	r0, [r7, #4]
  {
    /*Use interrupt line 1 for CPU2 Master*/
    HSEM->C2IER |= SemMask;
  }
#else
  HSEM_COMMON->IER |= SemMask;
 8100d58:	4b05      	ldr	r3, [pc, #20]	; (8100d70 <HAL_HSEM_ActivateNotification+0x20>)
 8100d5a:	681a      	ldr	r2, [r3, #0]
 8100d5c:	4904      	ldr	r1, [pc, #16]	; (8100d70 <HAL_HSEM_ActivateNotification+0x20>)
 8100d5e:	687b      	ldr	r3, [r7, #4]
 8100d60:	4313      	orrs	r3, r2
 8100d62:	600b      	str	r3, [r1, #0]
#endif
}
 8100d64:	bf00      	nop
 8100d66:	370c      	adds	r7, #12
 8100d68:	46bd      	mov	sp, r7
 8100d6a:	f85d 7b04 	ldr.w	r7, [sp], #4
 8100d6e:	4770      	bx	lr
 8100d70:	58026510 	.word	0x58026510

08100d74 <HAL_PWREx_EnterSTOPMode>:
  *            @arg PWR_D2_DOMAIN : Enter D2 Domain to DSTOP mode.
  *            @arg PWR_D3_DOMAIN : Enter D3/SRD Domain to DSTOP mode.
  * @retval None.
  */
void HAL_PWREx_EnterSTOPMode (uint32_t Regulator, uint8_t STOPEntry, uint32_t Domain)
{
 8100d74:	b580      	push	{r7, lr}
 8100d76:	b084      	sub	sp, #16
 8100d78:	af00      	add	r7, sp, #0
 8100d7a:	60f8      	str	r0, [r7, #12]
 8100d7c:	460b      	mov	r3, r1
 8100d7e:	607a      	str	r2, [r7, #4]
 8100d80:	72fb      	strb	r3, [r7, #11]
  assert_param (IS_PWR_REGULATOR (Regulator));
  assert_param (IS_PWR_STOP_ENTRY (STOPEntry));
  assert_param (IS_PWR_DOMAIN (Domain));

  /* Select the regulator state in Stop mode */
  MODIFY_REG (PWR->CR1, PWR_CR1_LPDS, Regulator);
 8100d82:	4b37      	ldr	r3, [pc, #220]	; (8100e60 <HAL_PWREx_EnterSTOPMode+0xec>)
 8100d84:	681b      	ldr	r3, [r3, #0]
 8100d86:	f023 0201 	bic.w	r2, r3, #1
 8100d8a:	4935      	ldr	r1, [pc, #212]	; (8100e60 <HAL_PWREx_EnterSTOPMode+0xec>)
 8100d8c:	68fb      	ldr	r3, [r7, #12]
 8100d8e:	4313      	orrs	r3, r2
 8100d90:	600b      	str	r3, [r1, #0]

  /* Select the domain Power Down DeepSleep */
  if (Domain == PWR_D1_DOMAIN)
 8100d92:	687b      	ldr	r3, [r7, #4]
 8100d94:	2b00      	cmp	r3, #0
 8100d96:	d123      	bne.n	8100de0 <HAL_PWREx_EnterSTOPMode+0x6c>
  {
#if defined (DUAL_CORE)
    /* Check current core */
    if (HAL_GetCurrentCPUID () != CM7_CPUID)
 8100d98:	f7ff fdfc 	bl	8100994 <HAL_GetCurrentCPUID>
 8100d9c:	4603      	mov	r3, r0
 8100d9e:	2b03      	cmp	r3, #3
 8100da0:	d158      	bne.n	8100e54 <HAL_PWREx_EnterSTOPMode+0xe0>
      return;
    }
#endif /* defined (DUAL_CORE) */

    /* Keep DSTOP mode when D1/CD domain enters Deepsleep */
    CLEAR_BIT (PWR->CPUCR, PWR_CPUCR_PDDS_D1);
 8100da2:	4b2f      	ldr	r3, [pc, #188]	; (8100e60 <HAL_PWREx_EnterSTOPMode+0xec>)
 8100da4:	691b      	ldr	r3, [r3, #16]
 8100da6:	4a2e      	ldr	r2, [pc, #184]	; (8100e60 <HAL_PWREx_EnterSTOPMode+0xec>)
 8100da8:	f023 0301 	bic.w	r3, r3, #1
 8100dac:	6113      	str	r3, [r2, #16]

    /* Set SLEEPDEEP bit of Cortex System Control Register */
    SET_BIT (SCB->SCR, SCB_SCR_SLEEPDEEP_Msk);
 8100dae:	4b2d      	ldr	r3, [pc, #180]	; (8100e64 <HAL_PWREx_EnterSTOPMode+0xf0>)
 8100db0:	691b      	ldr	r3, [r3, #16]
 8100db2:	4a2c      	ldr	r2, [pc, #176]	; (8100e64 <HAL_PWREx_EnterSTOPMode+0xf0>)
 8100db4:	f043 0304 	orr.w	r3, r3, #4
 8100db8:	6113      	str	r3, [r2, #16]
  \details Acts as a special kind of Data Memory Barrier.
           It completes when all explicit memory accesses before this instruction complete.
 */
__STATIC_FORCEINLINE void __DSB(void)
{
  __ASM volatile ("dsb 0xF":::"memory");
 8100dba:	f3bf 8f4f 	dsb	sy
}
 8100dbe:	bf00      	nop
  __ASM volatile ("isb 0xF":::"memory");
 8100dc0:	f3bf 8f6f 	isb	sy
}
 8100dc4:	bf00      	nop
    /* Ensure that all instructions are done before entering STOP mode */
    __DSB ();
    __ISB ();

    /* Select Stop mode entry */
    if (STOPEntry == PWR_STOPENTRY_WFI)
 8100dc6:	7afb      	ldrb	r3, [r7, #11]
 8100dc8:	2b01      	cmp	r3, #1
 8100dca:	d101      	bne.n	8100dd0 <HAL_PWREx_EnterSTOPMode+0x5c>
    {
      /* Request Wait For Interrupt */
      __WFI ();
 8100dcc:	bf30      	wfi
 8100dce:	e000      	b.n	8100dd2 <HAL_PWREx_EnterSTOPMode+0x5e>
    }
    else
    {
      /* Request Wait For Event */
      __WFE ();
 8100dd0:	bf20      	wfe
    }

    /* Clear SLEEPDEEP bit of Cortex-Mx in the System Control Register */
    CLEAR_BIT (SCB->SCR, SCB_SCR_SLEEPDEEP_Msk);
 8100dd2:	4b24      	ldr	r3, [pc, #144]	; (8100e64 <HAL_PWREx_EnterSTOPMode+0xf0>)
 8100dd4:	691b      	ldr	r3, [r3, #16]
 8100dd6:	4a23      	ldr	r2, [pc, #140]	; (8100e64 <HAL_PWREx_EnterSTOPMode+0xf0>)
 8100dd8:	f023 0304 	bic.w	r3, r3, #4
 8100ddc:	6113      	str	r3, [r2, #16]
 8100dde:	e03c      	b.n	8100e5a <HAL_PWREx_EnterSTOPMode+0xe6>
  }
#if defined (PWR_CPUCR_PDDS_D2)
  else if (Domain == PWR_D2_DOMAIN)
 8100de0:	687b      	ldr	r3, [r7, #4]
 8100de2:	2b01      	cmp	r3, #1
 8100de4:	d123      	bne.n	8100e2e <HAL_PWREx_EnterSTOPMode+0xba>
  {
#if defined (DUAL_CORE)
    /* Check current core */
    if (HAL_GetCurrentCPUID () != CM4_CPUID)
 8100de6:	f7ff fdd5 	bl	8100994 <HAL_GetCurrentCPUID>
 8100dea:	4603      	mov	r3, r0
 8100dec:	2b01      	cmp	r3, #1
 8100dee:	d133      	bne.n	8100e58 <HAL_PWREx_EnterSTOPMode+0xe4>
      */
      return;
    }

    /* Keep DSTOP mode when D2 domain enters Deepsleep */
    CLEAR_BIT (PWR->CPU2CR, PWR_CPU2CR_PDDS_D2);
 8100df0:	4b1b      	ldr	r3, [pc, #108]	; (8100e60 <HAL_PWREx_EnterSTOPMode+0xec>)
 8100df2:	695b      	ldr	r3, [r3, #20]
 8100df4:	4a1a      	ldr	r2, [pc, #104]	; (8100e60 <HAL_PWREx_EnterSTOPMode+0xec>)
 8100df6:	f023 0302 	bic.w	r3, r3, #2
 8100dfa:	6153      	str	r3, [r2, #20]

    /* Set SLEEPDEEP bit of Cortex System Control Register */
    SET_BIT (SCB->SCR, SCB_SCR_SLEEPDEEP_Msk);
 8100dfc:	4b19      	ldr	r3, [pc, #100]	; (8100e64 <HAL_PWREx_EnterSTOPMode+0xf0>)
 8100dfe:	691b      	ldr	r3, [r3, #16]
 8100e00:	4a18      	ldr	r2, [pc, #96]	; (8100e64 <HAL_PWREx_EnterSTOPMode+0xf0>)
 8100e02:	f043 0304 	orr.w	r3, r3, #4
 8100e06:	6113      	str	r3, [r2, #16]
  __ASM volatile ("dsb 0xF":::"memory");
 8100e08:	f3bf 8f4f 	dsb	sy
}
 8100e0c:	bf00      	nop
  __ASM volatile ("isb 0xF":::"memory");
 8100e0e:	f3bf 8f6f 	isb	sy
}
 8100e12:	bf00      	nop
    /* Ensure that all instructions are done before entering STOP mode */
    __DSB ();
    __ISB ();

    /* Select Stop mode entry */
    if (STOPEntry == PWR_STOPENTRY_WFI)
 8100e14:	7afb      	ldrb	r3, [r7, #11]
 8100e16:	2b01      	cmp	r3, #1
 8100e18:	d101      	bne.n	8100e1e <HAL_PWREx_EnterSTOPMode+0xaa>
    {
      /* Request Wait For Interrupt */
      __WFI ();
 8100e1a:	bf30      	wfi
 8100e1c:	e000      	b.n	8100e20 <HAL_PWREx_EnterSTOPMode+0xac>
    }
    else
    {
      /* Request Wait For Event */
      __WFE ();
 8100e1e:	bf20      	wfe
    }

    /* Clear SLEEPDEEP bit of Cortex-Mx in the System Control Register */
    CLEAR_BIT (SCB->SCR, SCB_SCR_SLEEPDEEP_Msk);
 8100e20:	4b10      	ldr	r3, [pc, #64]	; (8100e64 <HAL_PWREx_EnterSTOPMode+0xf0>)
 8100e22:	691b      	ldr	r3, [r3, #16]
 8100e24:	4a0f      	ldr	r2, [pc, #60]	; (8100e64 <HAL_PWREx_EnterSTOPMode+0xf0>)
 8100e26:	f023 0304 	bic.w	r3, r3, #4
 8100e2a:	6113      	str	r3, [r2, #16]
 8100e2c:	e015      	b.n	8100e5a <HAL_PWREx_EnterSTOPMode+0xe6>
#endif /* defined (PWR_CPUCR_PDDS_D2) */
  else
  {
#if defined (DUAL_CORE)
    /* Check current core */
    if (HAL_GetCurrentCPUID () == CM7_CPUID)
 8100e2e:	f7ff fdb1 	bl	8100994 <HAL_GetCurrentCPUID>
 8100e32:	4603      	mov	r3, r0
 8100e34:	2b03      	cmp	r3, #3
 8100e36:	d106      	bne.n	8100e46 <HAL_PWREx_EnterSTOPMode+0xd2>
    {
      /* Keep DSTOP mode when D3 domain enters Deepsleep */
      CLEAR_BIT (PWR->CPUCR, PWR_CPUCR_PDDS_D3);
 8100e38:	4b09      	ldr	r3, [pc, #36]	; (8100e60 <HAL_PWREx_EnterSTOPMode+0xec>)
 8100e3a:	691b      	ldr	r3, [r3, #16]
 8100e3c:	4a08      	ldr	r2, [pc, #32]	; (8100e60 <HAL_PWREx_EnterSTOPMode+0xec>)
 8100e3e:	f023 0304 	bic.w	r3, r3, #4
 8100e42:	6113      	str	r3, [r2, #16]
 8100e44:	e009      	b.n	8100e5a <HAL_PWREx_EnterSTOPMode+0xe6>
    }
    else
    {
      /* Keep DSTOP mode when D3 domain enters Deepsleep */
      CLEAR_BIT (PWR->CPU2CR, PWR_CPU2CR_PDDS_D3);
 8100e46:	4b06      	ldr	r3, [pc, #24]	; (8100e60 <HAL_PWREx_EnterSTOPMode+0xec>)
 8100e48:	695b      	ldr	r3, [r3, #20]
 8100e4a:	4a05      	ldr	r2, [pc, #20]	; (8100e60 <HAL_PWREx_EnterSTOPMode+0xec>)
 8100e4c:	f023 0304 	bic.w	r3, r3, #4
 8100e50:	6153      	str	r3, [r2, #20]
 8100e52:	e002      	b.n	8100e5a <HAL_PWREx_EnterSTOPMode+0xe6>
      return;
 8100e54:	bf00      	nop
 8100e56:	e000      	b.n	8100e5a <HAL_PWREx_EnterSTOPMode+0xe6>
      return;
 8100e58:	bf00      	nop
#else
    /* Keep DSTOP mode when D3/SRD domain enters Deepsleep */
    CLEAR_BIT (PWR->CPUCR, PWR_CPUCR_PDDS_D3);
#endif  /* defined (DUAL_CORE) */
  }
}
 8100e5a:	3710      	adds	r7, #16
 8100e5c:	46bd      	mov	sp, r7
 8100e5e:	bd80      	pop	{r7, pc}
 8100e60:	58024800 	.word	0x58024800
 8100e64:	e000ed00 	.word	0xe000ed00

08100e68 <HAL_PWREx_ClearPendingEvent>:
  *         enter low power mode using Wait For Event request.
  * @note   Cortex-M7 must be in CRUN mode when calling this API by Cortex-M4.
  * @retval None.
  */
void HAL_PWREx_ClearPendingEvent (void)
{
 8100e68:	b580      	push	{r7, lr}
 8100e6a:	af00      	add	r7, sp, #0
#if defined (DUAL_CORE)
  /* Check the current Core */
  if (HAL_GetCurrentCPUID () == CM7_CPUID)
 8100e6c:	f7ff fd92 	bl	8100994 <HAL_GetCurrentCPUID>
 8100e70:	4603      	mov	r3, r0
 8100e72:	2b03      	cmp	r3, #3
 8100e74:	d101      	bne.n	8100e7a <HAL_PWREx_ClearPendingEvent+0x12>
  {
    __WFE ();
 8100e76:	bf20      	wfe
    __WFE ();
  }
#else
  __WFE ();
#endif /* defined (DUAL_CORE) */
}
 8100e78:	e001      	b.n	8100e7e <HAL_PWREx_ClearPendingEvent+0x16>
    __SEV ();
 8100e7a:	bf40      	sev
    __WFE ();
 8100e7c:	bf20      	wfe
}
 8100e7e:	bf00      	nop
 8100e80:	bd80      	pop	{r7, pc}
	...

08100e84 <HAL_RCC_GetSysClockFreq>:
  *
  *
  * @retval SYSCLK frequency
  */
uint32_t HAL_RCC_GetSysClockFreq(void)
{
 8100e84:	b480      	push	{r7}
 8100e86:	b089      	sub	sp, #36	; 0x24
 8100e88:	af00      	add	r7, sp, #0
  float_t fracn1, pllvco;
  uint32_t sysclockfreq;

  /* Get SYSCLK source -------------------------------------------------------*/

  switch (RCC->CFGR & RCC_CFGR_SWS)
 8100e8a:	4bb3      	ldr	r3, [pc, #716]	; (8101158 <HAL_RCC_GetSysClockFreq+0x2d4>)
 8100e8c:	691b      	ldr	r3, [r3, #16]
 8100e8e:	f003 0338 	and.w	r3, r3, #56	; 0x38
 8100e92:	2b18      	cmp	r3, #24
 8100e94:	f200 8155 	bhi.w	8101142 <HAL_RCC_GetSysClockFreq+0x2be>
 8100e98:	a201      	add	r2, pc, #4	; (adr r2, 8100ea0 <HAL_RCC_GetSysClockFreq+0x1c>)
 8100e9a:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 8100e9e:	bf00      	nop
 8100ea0:	08100f05 	.word	0x08100f05
 8100ea4:	08101143 	.word	0x08101143
 8100ea8:	08101143 	.word	0x08101143
 8100eac:	08101143 	.word	0x08101143
 8100eb0:	08101143 	.word	0x08101143
 8100eb4:	08101143 	.word	0x08101143
 8100eb8:	08101143 	.word	0x08101143
 8100ebc:	08101143 	.word	0x08101143
 8100ec0:	08100f2b 	.word	0x08100f2b
 8100ec4:	08101143 	.word	0x08101143
 8100ec8:	08101143 	.word	0x08101143
 8100ecc:	08101143 	.word	0x08101143
 8100ed0:	08101143 	.word	0x08101143
 8100ed4:	08101143 	.word	0x08101143
 8100ed8:	08101143 	.word	0x08101143
 8100edc:	08101143 	.word	0x08101143
 8100ee0:	08100f31 	.word	0x08100f31
 8100ee4:	08101143 	.word	0x08101143
 8100ee8:	08101143 	.word	0x08101143
 8100eec:	08101143 	.word	0x08101143
 8100ef0:	08101143 	.word	0x08101143
 8100ef4:	08101143 	.word	0x08101143
 8100ef8:	08101143 	.word	0x08101143
 8100efc:	08101143 	.word	0x08101143
 8100f00:	08100f37 	.word	0x08100f37
  {
  case RCC_CFGR_SWS_HSI:  /* HSI used as system clock source */

   if (__HAL_RCC_GET_FLAG(RCC_FLAG_HSIDIV) != 0U)
 8100f04:	4b94      	ldr	r3, [pc, #592]	; (8101158 <HAL_RCC_GetSysClockFreq+0x2d4>)
 8100f06:	681b      	ldr	r3, [r3, #0]
 8100f08:	f003 0320 	and.w	r3, r3, #32
 8100f0c:	2b00      	cmp	r3, #0
 8100f0e:	d009      	beq.n	8100f24 <HAL_RCC_GetSysClockFreq+0xa0>
      {
        sysclockfreq = (uint32_t) (HSI_VALUE >> (__HAL_RCC_GET_HSI_DIVIDER()>> 3));
 8100f10:	4b91      	ldr	r3, [pc, #580]	; (8101158 <HAL_RCC_GetSysClockFreq+0x2d4>)
 8100f12:	681b      	ldr	r3, [r3, #0]
 8100f14:	08db      	lsrs	r3, r3, #3
 8100f16:	f003 0303 	and.w	r3, r3, #3
 8100f1a:	4a90      	ldr	r2, [pc, #576]	; (810115c <HAL_RCC_GetSysClockFreq+0x2d8>)
 8100f1c:	fa22 f303 	lsr.w	r3, r2, r3
 8100f20:	61bb      	str	r3, [r7, #24]
      else
      {
        sysclockfreq = (uint32_t) HSI_VALUE;
      }

    break;
 8100f22:	e111      	b.n	8101148 <HAL_RCC_GetSysClockFreq+0x2c4>
        sysclockfreq = (uint32_t) HSI_VALUE;
 8100f24:	4b8d      	ldr	r3, [pc, #564]	; (810115c <HAL_RCC_GetSysClockFreq+0x2d8>)
 8100f26:	61bb      	str	r3, [r7, #24]
    break;
 8100f28:	e10e      	b.n	8101148 <HAL_RCC_GetSysClockFreq+0x2c4>

  case RCC_CFGR_SWS_CSI:  /* CSI used as system clock  source */
    sysclockfreq = CSI_VALUE;
 8100f2a:	4b8d      	ldr	r3, [pc, #564]	; (8101160 <HAL_RCC_GetSysClockFreq+0x2dc>)
 8100f2c:	61bb      	str	r3, [r7, #24]
    break;
 8100f2e:	e10b      	b.n	8101148 <HAL_RCC_GetSysClockFreq+0x2c4>

  case RCC_CFGR_SWS_HSE:  /* HSE used as system clock  source */
    sysclockfreq = HSE_VALUE;
 8100f30:	4b8c      	ldr	r3, [pc, #560]	; (8101164 <HAL_RCC_GetSysClockFreq+0x2e0>)
 8100f32:	61bb      	str	r3, [r7, #24]
    break;
 8100f34:	e108      	b.n	8101148 <HAL_RCC_GetSysClockFreq+0x2c4>
  case RCC_CFGR_SWS_PLL1:  /* PLL1 used as system clock  source */

    /* PLL_VCO = (HSE_VALUE or HSI_VALUE or CSI_VALUE/ PLLM) * PLLN
    SYSCLK = PLL_VCO / PLLR
    */
    pllsource = (RCC->PLLCKSELR & RCC_PLLCKSELR_PLLSRC);
 8100f36:	4b88      	ldr	r3, [pc, #544]	; (8101158 <HAL_RCC_GetSysClockFreq+0x2d4>)
 8100f38:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8100f3a:	f003 0303 	and.w	r3, r3, #3
 8100f3e:	617b      	str	r3, [r7, #20]
    pllm = ((RCC->PLLCKSELR & RCC_PLLCKSELR_DIVM1)>> 4)  ;
 8100f40:	4b85      	ldr	r3, [pc, #532]	; (8101158 <HAL_RCC_GetSysClockFreq+0x2d4>)
 8100f42:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8100f44:	091b      	lsrs	r3, r3, #4
 8100f46:	f003 033f 	and.w	r3, r3, #63	; 0x3f
 8100f4a:	613b      	str	r3, [r7, #16]
    pllfracen = ((RCC-> PLLCFGR & RCC_PLLCFGR_PLL1FRACEN)>>RCC_PLLCFGR_PLL1FRACEN_Pos);
 8100f4c:	4b82      	ldr	r3, [pc, #520]	; (8101158 <HAL_RCC_GetSysClockFreq+0x2d4>)
 8100f4e:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8100f50:	f003 0301 	and.w	r3, r3, #1
 8100f54:	60fb      	str	r3, [r7, #12]
    fracn1 = (float_t)(uint32_t)(pllfracen* ((RCC->PLL1FRACR & RCC_PLL1FRACR_FRACN1)>> 3));
 8100f56:	4b80      	ldr	r3, [pc, #512]	; (8101158 <HAL_RCC_GetSysClockFreq+0x2d4>)
 8100f58:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 8100f5a:	08db      	lsrs	r3, r3, #3
 8100f5c:	f3c3 030c 	ubfx	r3, r3, #0, #13
 8100f60:	68fa      	ldr	r2, [r7, #12]
 8100f62:	fb02 f303 	mul.w	r3, r2, r3
 8100f66:	ee07 3a90 	vmov	s15, r3
 8100f6a:	eef8 7a67 	vcvt.f32.u32	s15, s15
 8100f6e:	edc7 7a02 	vstr	s15, [r7, #8]

    if (pllm != 0U)
 8100f72:	693b      	ldr	r3, [r7, #16]
 8100f74:	2b00      	cmp	r3, #0
 8100f76:	f000 80e1 	beq.w	810113c <HAL_RCC_GetSysClockFreq+0x2b8>
 8100f7a:	697b      	ldr	r3, [r7, #20]
 8100f7c:	2b02      	cmp	r3, #2
 8100f7e:	f000 8083 	beq.w	8101088 <HAL_RCC_GetSysClockFreq+0x204>
 8100f82:	697b      	ldr	r3, [r7, #20]
 8100f84:	2b02      	cmp	r3, #2
 8100f86:	f200 80a1 	bhi.w	81010cc <HAL_RCC_GetSysClockFreq+0x248>
 8100f8a:	697b      	ldr	r3, [r7, #20]
 8100f8c:	2b00      	cmp	r3, #0
 8100f8e:	d003      	beq.n	8100f98 <HAL_RCC_GetSysClockFreq+0x114>
 8100f90:	697b      	ldr	r3, [r7, #20]
 8100f92:	2b01      	cmp	r3, #1
 8100f94:	d056      	beq.n	8101044 <HAL_RCC_GetSysClockFreq+0x1c0>
 8100f96:	e099      	b.n	81010cc <HAL_RCC_GetSysClockFreq+0x248>
    {
      switch (pllsource)
      {
      case RCC_PLLSOURCE_HSI:  /* HSI used as PLL clock source */

       if (__HAL_RCC_GET_FLAG(RCC_FLAG_HSIDIV) != 0U)
 8100f98:	4b6f      	ldr	r3, [pc, #444]	; (8101158 <HAL_RCC_GetSysClockFreq+0x2d4>)
 8100f9a:	681b      	ldr	r3, [r3, #0]
 8100f9c:	f003 0320 	and.w	r3, r3, #32
 8100fa0:	2b00      	cmp	r3, #0
 8100fa2:	d02d      	beq.n	8101000 <HAL_RCC_GetSysClockFreq+0x17c>
        {
          hsivalue= (HSI_VALUE >> (__HAL_RCC_GET_HSI_DIVIDER()>> 3));
 8100fa4:	4b6c      	ldr	r3, [pc, #432]	; (8101158 <HAL_RCC_GetSysClockFreq+0x2d4>)
 8100fa6:	681b      	ldr	r3, [r3, #0]
 8100fa8:	08db      	lsrs	r3, r3, #3
 8100faa:	f003 0303 	and.w	r3, r3, #3
 8100fae:	4a6b      	ldr	r2, [pc, #428]	; (810115c <HAL_RCC_GetSysClockFreq+0x2d8>)
 8100fb0:	fa22 f303 	lsr.w	r3, r2, r3
 8100fb4:	607b      	str	r3, [r7, #4]
          pllvco = ( (float_t)hsivalue / (float_t)pllm) * ((float_t)(uint32_t)(RCC->PLL1DIVR & RCC_PLL1DIVR_N1) + (fracn1/(float_t)0x2000) +(float_t)1 );
 8100fb6:	687b      	ldr	r3, [r7, #4]
 8100fb8:	ee07 3a90 	vmov	s15, r3
 8100fbc:	eef8 6a67 	vcvt.f32.u32	s13, s15
 8100fc0:	693b      	ldr	r3, [r7, #16]
 8100fc2:	ee07 3a90 	vmov	s15, r3
 8100fc6:	eef8 7a67 	vcvt.f32.u32	s15, s15
 8100fca:	ee86 7aa7 	vdiv.f32	s14, s13, s15
 8100fce:	4b62      	ldr	r3, [pc, #392]	; (8101158 <HAL_RCC_GetSysClockFreq+0x2d4>)
 8100fd0:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8100fd2:	f3c3 0308 	ubfx	r3, r3, #0, #9
 8100fd6:	ee07 3a90 	vmov	s15, r3
 8100fda:	eef8 6a67 	vcvt.f32.u32	s13, s15
 8100fde:	ed97 6a02 	vldr	s12, [r7, #8]
 8100fe2:	eddf 5a61 	vldr	s11, [pc, #388]	; 8101168 <HAL_RCC_GetSysClockFreq+0x2e4>
 8100fe6:	eec6 7a25 	vdiv.f32	s15, s12, s11
 8100fea:	ee76 7aa7 	vadd.f32	s15, s13, s15
 8100fee:	eef7 6a00 	vmov.f32	s13, #112	; 0x3f800000  1.0
 8100ff2:	ee77 7aa6 	vadd.f32	s15, s15, s13
 8100ff6:	ee67 7a27 	vmul.f32	s15, s14, s15
 8100ffa:	edc7 7a07 	vstr	s15, [r7, #28]
        }
        else
        {
          pllvco = ((float_t)HSI_VALUE / (float_t)pllm) * ((float_t)(uint32_t)(RCC->PLL1DIVR & RCC_PLL1DIVR_N1) + (fracn1/(float_t)0x2000) +(float_t)1 );
        }
        break;
 8100ffe:	e087      	b.n	8101110 <HAL_RCC_GetSysClockFreq+0x28c>
          pllvco = ((float_t)HSI_VALUE / (float_t)pllm) * ((float_t)(uint32_t)(RCC->PLL1DIVR & RCC_PLL1DIVR_N1) + (fracn1/(float_t)0x2000) +(float_t)1 );
 8101000:	693b      	ldr	r3, [r7, #16]
 8101002:	ee07 3a90 	vmov	s15, r3
 8101006:	eef8 7a67 	vcvt.f32.u32	s15, s15
 810100a:	eddf 6a58 	vldr	s13, [pc, #352]	; 810116c <HAL_RCC_GetSysClockFreq+0x2e8>
 810100e:	ee86 7aa7 	vdiv.f32	s14, s13, s15
 8101012:	4b51      	ldr	r3, [pc, #324]	; (8101158 <HAL_RCC_GetSysClockFreq+0x2d4>)
 8101014:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8101016:	f3c3 0308 	ubfx	r3, r3, #0, #9
 810101a:	ee07 3a90 	vmov	s15, r3
 810101e:	eef8 6a67 	vcvt.f32.u32	s13, s15
 8101022:	ed97 6a02 	vldr	s12, [r7, #8]
 8101026:	eddf 5a50 	vldr	s11, [pc, #320]	; 8101168 <HAL_RCC_GetSysClockFreq+0x2e4>
 810102a:	eec6 7a25 	vdiv.f32	s15, s12, s11
 810102e:	ee76 7aa7 	vadd.f32	s15, s13, s15
 8101032:	eef7 6a00 	vmov.f32	s13, #112	; 0x3f800000  1.0
 8101036:	ee77 7aa6 	vadd.f32	s15, s15, s13
 810103a:	ee67 7a27 	vmul.f32	s15, s14, s15
 810103e:	edc7 7a07 	vstr	s15, [r7, #28]
        break;
 8101042:	e065      	b.n	8101110 <HAL_RCC_GetSysClockFreq+0x28c>

      case RCC_PLLSOURCE_CSI:  /* CSI used as PLL clock source */
        pllvco = ((float_t)CSI_VALUE / (float_t)pllm) * ((float_t)(uint32_t)(RCC->PLL1DIVR & RCC_PLL1DIVR_N1) + (fracn1/(float_t)0x2000) +(float_t)1 );
 8101044:	693b      	ldr	r3, [r7, #16]
 8101046:	ee07 3a90 	vmov	s15, r3
 810104a:	eef8 7a67 	vcvt.f32.u32	s15, s15
 810104e:	eddf 6a48 	vldr	s13, [pc, #288]	; 8101170 <HAL_RCC_GetSysClockFreq+0x2ec>
 8101052:	ee86 7aa7 	vdiv.f32	s14, s13, s15
 8101056:	4b40      	ldr	r3, [pc, #256]	; (8101158 <HAL_RCC_GetSysClockFreq+0x2d4>)
 8101058:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 810105a:	f3c3 0308 	ubfx	r3, r3, #0, #9
 810105e:	ee07 3a90 	vmov	s15, r3
 8101062:	eef8 6a67 	vcvt.f32.u32	s13, s15
 8101066:	ed97 6a02 	vldr	s12, [r7, #8]
 810106a:	eddf 5a3f 	vldr	s11, [pc, #252]	; 8101168 <HAL_RCC_GetSysClockFreq+0x2e4>
 810106e:	eec6 7a25 	vdiv.f32	s15, s12, s11
 8101072:	ee76 7aa7 	vadd.f32	s15, s13, s15
 8101076:	eef7 6a00 	vmov.f32	s13, #112	; 0x3f800000  1.0
 810107a:	ee77 7aa6 	vadd.f32	s15, s15, s13
 810107e:	ee67 7a27 	vmul.f32	s15, s14, s15
 8101082:	edc7 7a07 	vstr	s15, [r7, #28]
        break;
 8101086:	e043      	b.n	8101110 <HAL_RCC_GetSysClockFreq+0x28c>

      case RCC_PLLSOURCE_HSE:  /* HSE used as PLL clock source */
        pllvco = ((float_t)HSE_VALUE / (float_t)pllm) * ((float_t)(uint32_t)(RCC->PLL1DIVR & RCC_PLL1DIVR_N1) + (fracn1/(float_t)0x2000) +(float_t)1 );
 8101088:	693b      	ldr	r3, [r7, #16]
 810108a:	ee07 3a90 	vmov	s15, r3
 810108e:	eef8 7a67 	vcvt.f32.u32	s15, s15
 8101092:	eddf 6a38 	vldr	s13, [pc, #224]	; 8101174 <HAL_RCC_GetSysClockFreq+0x2f0>
 8101096:	ee86 7aa7 	vdiv.f32	s14, s13, s15
 810109a:	4b2f      	ldr	r3, [pc, #188]	; (8101158 <HAL_RCC_GetSysClockFreq+0x2d4>)
 810109c:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 810109e:	f3c3 0308 	ubfx	r3, r3, #0, #9
 81010a2:	ee07 3a90 	vmov	s15, r3
 81010a6:	eef8 6a67 	vcvt.f32.u32	s13, s15
 81010aa:	ed97 6a02 	vldr	s12, [r7, #8]
 81010ae:	eddf 5a2e 	vldr	s11, [pc, #184]	; 8101168 <HAL_RCC_GetSysClockFreq+0x2e4>
 81010b2:	eec6 7a25 	vdiv.f32	s15, s12, s11
 81010b6:	ee76 7aa7 	vadd.f32	s15, s13, s15
 81010ba:	eef7 6a00 	vmov.f32	s13, #112	; 0x3f800000  1.0
 81010be:	ee77 7aa6 	vadd.f32	s15, s15, s13
 81010c2:	ee67 7a27 	vmul.f32	s15, s14, s15
 81010c6:	edc7 7a07 	vstr	s15, [r7, #28]
        break;
 81010ca:	e021      	b.n	8101110 <HAL_RCC_GetSysClockFreq+0x28c>

      default:
        pllvco = ((float_t)CSI_VALUE / (float_t)pllm) * ((float_t)(uint32_t)(RCC->PLL1DIVR & RCC_PLL1DIVR_N1) + (fracn1/(float_t)0x2000) +(float_t)1 );
 81010cc:	693b      	ldr	r3, [r7, #16]
 81010ce:	ee07 3a90 	vmov	s15, r3
 81010d2:	eef8 7a67 	vcvt.f32.u32	s15, s15
 81010d6:	eddf 6a26 	vldr	s13, [pc, #152]	; 8101170 <HAL_RCC_GetSysClockFreq+0x2ec>
 81010da:	ee86 7aa7 	vdiv.f32	s14, s13, s15
 81010de:	4b1e      	ldr	r3, [pc, #120]	; (8101158 <HAL_RCC_GetSysClockFreq+0x2d4>)
 81010e0:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 81010e2:	f3c3 0308 	ubfx	r3, r3, #0, #9
 81010e6:	ee07 3a90 	vmov	s15, r3
 81010ea:	eef8 6a67 	vcvt.f32.u32	s13, s15
 81010ee:	ed97 6a02 	vldr	s12, [r7, #8]
 81010f2:	eddf 5a1d 	vldr	s11, [pc, #116]	; 8101168 <HAL_RCC_GetSysClockFreq+0x2e4>
 81010f6:	eec6 7a25 	vdiv.f32	s15, s12, s11
 81010fa:	ee76 7aa7 	vadd.f32	s15, s13, s15
 81010fe:	eef7 6a00 	vmov.f32	s13, #112	; 0x3f800000  1.0
 8101102:	ee77 7aa6 	vadd.f32	s15, s15, s13
 8101106:	ee67 7a27 	vmul.f32	s15, s14, s15
 810110a:	edc7 7a07 	vstr	s15, [r7, #28]
        break;
 810110e:	bf00      	nop
      }
      pllp = (((RCC->PLL1DIVR & RCC_PLL1DIVR_P1) >>9) + 1U ) ;
 8101110:	4b11      	ldr	r3, [pc, #68]	; (8101158 <HAL_RCC_GetSysClockFreq+0x2d4>)
 8101112:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8101114:	0a5b      	lsrs	r3, r3, #9
 8101116:	f003 037f 	and.w	r3, r3, #127	; 0x7f
 810111a:	3301      	adds	r3, #1
 810111c:	603b      	str	r3, [r7, #0]
      sysclockfreq =  (uint32_t)(float_t)(pllvco/(float_t)pllp);
 810111e:	683b      	ldr	r3, [r7, #0]
 8101120:	ee07 3a90 	vmov	s15, r3
 8101124:	eeb8 7a67 	vcvt.f32.u32	s14, s15
 8101128:	edd7 6a07 	vldr	s13, [r7, #28]
 810112c:	eec6 7a87 	vdiv.f32	s15, s13, s14
 8101130:	eefc 7ae7 	vcvt.u32.f32	s15, s15
 8101134:	ee17 3a90 	vmov	r3, s15
 8101138:	61bb      	str	r3, [r7, #24]
    }
    else
    {
      sysclockfreq = 0U;
    }
    break;
 810113a:	e005      	b.n	8101148 <HAL_RCC_GetSysClockFreq+0x2c4>
      sysclockfreq = 0U;
 810113c:	2300      	movs	r3, #0
 810113e:	61bb      	str	r3, [r7, #24]
    break;
 8101140:	e002      	b.n	8101148 <HAL_RCC_GetSysClockFreq+0x2c4>

  default:
    sysclockfreq = CSI_VALUE;
 8101142:	4b07      	ldr	r3, [pc, #28]	; (8101160 <HAL_RCC_GetSysClockFreq+0x2dc>)
 8101144:	61bb      	str	r3, [r7, #24]
    break;
 8101146:	bf00      	nop
  }

  return sysclockfreq;
 8101148:	69bb      	ldr	r3, [r7, #24]
}
 810114a:	4618      	mov	r0, r3
 810114c:	3724      	adds	r7, #36	; 0x24
 810114e:	46bd      	mov	sp, r7
 8101150:	f85d 7b04 	ldr.w	r7, [sp], #4
 8101154:	4770      	bx	lr
 8101156:	bf00      	nop
 8101158:	58024400 	.word	0x58024400
 810115c:	03d09000 	.word	0x03d09000
 8101160:	003d0900 	.word	0x003d0900
 8101164:	017d7840 	.word	0x017d7840
 8101168:	46000000 	.word	0x46000000
 810116c:	4c742400 	.word	0x4c742400
 8101170:	4a742400 	.word	0x4a742400
 8101174:	4bbebc20 	.word	0x4bbebc20

08101178 <_tx_thread_system_resume>:
/*                                            resulting in version 6.1    */
/*                                                                        */
/**************************************************************************/
VOID  _tx_thread_system_resume(TX_THREAD *thread_ptr)
#ifndef TX_NOT_INTERRUPTABLE
{
 8101178:	b580      	push	{r7, lr}
 810117a:	b098      	sub	sp, #96	; 0x60
 810117c:	af00      	add	r7, sp, #0
 810117e:	6078      	str	r0, [r7, #4]
{
unsigned int posture;
#ifdef TX_PORT_USE_BASEPRI
    __asm__ volatile ("MRS  %0, BASEPRI ": "=r" (posture));
#else
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
 8101180:	f3ef 8310 	mrs	r3, PRIMASK
 8101184:	63bb      	str	r3, [r7, #56]	; 0x38
#endif
    return(posture);
 8101186:	6bbb      	ldr	r3, [r7, #56]	; 0x38

__attribute__( ( always_inline ) ) static inline unsigned int __disable_interrupts(void)
{
unsigned int int_posture;

    int_posture = __get_interrupt_posture();
 8101188:	637b      	str	r3, [r7, #52]	; 0x34

#ifdef TX_PORT_USE_BASEPRI
    __set_basepri_value(TX_PORT_BASEPRI);
#else
    __asm__ volatile ("CPSID i" : : : "memory");
 810118a:	b672      	cpsid	i
#endif
    return(int_posture);
 810118c:	6b7b      	ldr	r3, [r7, #52]	; 0x34
    /* Check this thread's stack.  */
    TX_THREAD_STACK_CHECK(thread_ptr)
#endif

    /* Lockout interrupts while the thread is being resumed.  */
    TX_DISABLE
 810118e:	65fb      	str	r3, [r7, #92]	; 0x5c

#ifndef TX_NO_TIMER

    /* Deactivate the timeout timer if necessary.  */
    if (thread_ptr -> tx_thread_timer.tx_timer_internal_list_head != TX_NULL)
 8101190:	687b      	ldr	r3, [r7, #4]
 8101192:	6e5b      	ldr	r3, [r3, #100]	; 0x64
 8101194:	2b00      	cmp	r3, #0
 8101196:	d005      	beq.n	81011a4 <_tx_thread_system_resume+0x2c>
    {

        /* Deactivate the thread's timeout timer.  */
        _tx_timer_system_deactivate(&(thread_ptr -> tx_thread_timer));
 8101198:	687b      	ldr	r3, [r7, #4]
 810119a:	334c      	adds	r3, #76	; 0x4c
 810119c:	4618      	mov	r0, r3
 810119e:	f000 f9a7 	bl	81014f0 <_tx_timer_system_deactivate>
 81011a2:	e002      	b.n	81011aa <_tx_thread_system_resume+0x32>
    }
    else
    {

        /* Clear the remaining time to ensure timer doesn't get activated.  */
        thread_ptr -> tx_thread_timer.tx_timer_internal_remaining_ticks =  ((ULONG) 0);
 81011a4:	687b      	ldr	r3, [r7, #4]
 81011a6:	2200      	movs	r2, #0
 81011a8:	64da      	str	r2, [r3, #76]	; 0x4c
        time_stamp =  entry_ptr -> tx_trace_buffer_entry_time_stamp;
    }
#endif

    /* Decrease the preempt disabled count.  */
    _tx_thread_preempt_disable--;
 81011aa:	4b8d      	ldr	r3, [pc, #564]	; (81013e0 <_tx_thread_system_resume+0x268>)
 81011ac:	681b      	ldr	r3, [r3, #0]
 81011ae:	3b01      	subs	r3, #1
 81011b0:	4a8b      	ldr	r2, [pc, #556]	; (81013e0 <_tx_thread_system_resume+0x268>)
 81011b2:	6013      	str	r3, [r2, #0]

    /* Determine if the thread is in the process of suspending.  If so, the thread
       control block is already on the linked list so nothing needs to be done.  */
    if (thread_ptr -> tx_thread_suspending == TX_FALSE)
 81011b4:	687b      	ldr	r3, [r7, #4]
 81011b6:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 81011b8:	2b00      	cmp	r3, #0
 81011ba:	f040 80c5 	bne.w	8101348 <_tx_thread_system_resume+0x1d0>
    {

        /* Thread is not in the process of suspending. Now check to make sure the thread
           has not already been resumed.  */
        if (thread_ptr -> tx_thread_state != TX_READY)
 81011be:	687b      	ldr	r3, [r7, #4]
 81011c0:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 81011c2:	2b00      	cmp	r3, #0
 81011c4:	f000 80d9 	beq.w	810137a <_tx_thread_system_resume+0x202>
        {

            /* No, now check to see if the delayed suspension flag is set.  */
            if (thread_ptr -> tx_thread_delayed_suspend == TX_FALSE)
 81011c8:	687b      	ldr	r3, [r7, #4]
 81011ca:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 81011cc:	2b00      	cmp	r3, #0
 81011ce:	f040 80b4 	bne.w	810133a <_tx_thread_system_resume+0x1c2>
                /* Resume the thread!  */

                /* Make this thread ready.  */

                /* Change the state to ready.  */
                thread_ptr -> tx_thread_state =  TX_READY;
 81011d2:	687b      	ldr	r3, [r7, #4]
 81011d4:	2200      	movs	r2, #0
 81011d6:	631a      	str	r2, [r3, #48]	; 0x30

                /* Pickup priority of thread.  */
                priority =  thread_ptr -> tx_thread_priority;
 81011d8:	687b      	ldr	r3, [r7, #4]
 81011da:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 81011dc:	65bb      	str	r3, [r7, #88]	; 0x58
                thread_ptr -> tx_thread_performance_resume_count++;
#endif

                /* Determine if there are other threads at this priority that are
                   ready.  */
                head_ptr =  _tx_thread_priority_list[priority];
 81011de:	4a81      	ldr	r2, [pc, #516]	; (81013e4 <_tx_thread_system_resume+0x26c>)
 81011e0:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 81011e2:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 81011e6:	657b      	str	r3, [r7, #84]	; 0x54
                if (head_ptr == TX_NULL)
 81011e8:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 81011ea:	2b00      	cmp	r3, #0
 81011ec:	f040 8095 	bne.w	810131a <_tx_thread_system_resume+0x1a2>
                {

                    /* First thread at this priority ready.  Add to the front of the list.  */
                    _tx_thread_priority_list[priority] =       thread_ptr;
 81011f0:	497c      	ldr	r1, [pc, #496]	; (81013e4 <_tx_thread_system_resume+0x26c>)
 81011f2:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 81011f4:	687a      	ldr	r2, [r7, #4]
 81011f6:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
                    thread_ptr -> tx_thread_ready_next =       thread_ptr;
 81011fa:	687b      	ldr	r3, [r7, #4]
 81011fc:	687a      	ldr	r2, [r7, #4]
 81011fe:	621a      	str	r2, [r3, #32]
                    thread_ptr -> tx_thread_ready_previous =   thread_ptr;
 8101200:	687b      	ldr	r3, [r7, #4]
 8101202:	687a      	ldr	r2, [r7, #4]
 8101204:	625a      	str	r2, [r3, #36]	; 0x24

#if TX_MAX_PRIORITIES > 32

                    /* Calculate the index into the bit map array.  */
                    map_index =  priority/((UINT) 32);
 8101206:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 8101208:	095b      	lsrs	r3, r3, #5
 810120a:	64fb      	str	r3, [r7, #76]	; 0x4c

                    /* Set the active bit to remember that the priority map has something set.  */
                    TX_DIV32_BIT_SET(priority, priority_bit)
 810120c:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 810120e:	095b      	lsrs	r3, r3, #5
 8101210:	2201      	movs	r2, #1
 8101212:	fa02 f303 	lsl.w	r3, r2, r3
 8101216:	64bb      	str	r3, [r7, #72]	; 0x48
                    _tx_thread_priority_map_active =  _tx_thread_priority_map_active | priority_bit;
 8101218:	4b73      	ldr	r3, [pc, #460]	; (81013e8 <_tx_thread_system_resume+0x270>)
 810121a:	681a      	ldr	r2, [r3, #0]
 810121c:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 810121e:	4313      	orrs	r3, r2
 8101220:	4a71      	ldr	r2, [pc, #452]	; (81013e8 <_tx_thread_system_resume+0x270>)
 8101222:	6013      	str	r3, [r2, #0]
#endif

                    /* Or in the thread's priority bit.  */
                    TX_MOD32_BIT_SET(priority, priority_bit)
 8101224:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 8101226:	f003 031f 	and.w	r3, r3, #31
 810122a:	2201      	movs	r2, #1
 810122c:	fa02 f303 	lsl.w	r3, r2, r3
 8101230:	64bb      	str	r3, [r7, #72]	; 0x48
                    _tx_thread_priority_maps[MAP_INDEX] =  _tx_thread_priority_maps[MAP_INDEX] | priority_bit;
 8101232:	4a6e      	ldr	r2, [pc, #440]	; (81013ec <_tx_thread_system_resume+0x274>)
 8101234:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 8101236:	f852 2023 	ldr.w	r2, [r2, r3, lsl #2]
 810123a:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 810123c:	431a      	orrs	r2, r3
 810123e:	496b      	ldr	r1, [pc, #428]	; (81013ec <_tx_thread_system_resume+0x274>)
 8101240:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 8101242:	f841 2023 	str.w	r2, [r1, r3, lsl #2]

                    /* Determine if this newly ready thread is the highest priority.  */
                    if (priority < _tx_thread_highest_priority)
 8101246:	4b6a      	ldr	r3, [pc, #424]	; (81013f0 <_tx_thread_system_resume+0x278>)
 8101248:	681b      	ldr	r3, [r3, #0]
 810124a:	6dba      	ldr	r2, [r7, #88]	; 0x58
 810124c:	429a      	cmp	r2, r3
 810124e:	f080 8094 	bcs.w	810137a <_tx_thread_system_resume+0x202>
                    {

                        /* A new highest priority thread is present. */

                        /* Update the highest priority variable.  */
                        _tx_thread_highest_priority =  priority;
 8101252:	4a67      	ldr	r2, [pc, #412]	; (81013f0 <_tx_thread_system_resume+0x278>)
 8101254:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 8101256:	6013      	str	r3, [r2, #0]

                        /* Pickup the execute pointer. Since it is going to be referenced multiple
                           times, it is placed in a local variable.  */
                        execute_ptr =  _tx_thread_execute_ptr;
 8101258:	4b66      	ldr	r3, [pc, #408]	; (81013f4 <_tx_thread_system_resume+0x27c>)
 810125a:	681b      	ldr	r3, [r3, #0]
 810125c:	647b      	str	r3, [r7, #68]	; 0x44

                        /* Determine if no thread is currently executing.  */
                        if (execute_ptr == TX_NULL)
 810125e:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 8101260:	2b00      	cmp	r3, #0
 8101262:	d103      	bne.n	810126c <_tx_thread_system_resume+0xf4>
                        {

                            /* Simply setup the execute pointer.  */
                            _tx_thread_execute_ptr =  thread_ptr;
 8101264:	4a63      	ldr	r2, [pc, #396]	; (81013f4 <_tx_thread_system_resume+0x27c>)
 8101266:	687b      	ldr	r3, [r7, #4]
 8101268:	6013      	str	r3, [r2, #0]
 810126a:	e086      	b.n	810137a <_tx_thread_system_resume+0x202>
                        {

                            /* Another thread has been scheduled for execution.  */

                            /* Check to see if this is a higher priority thread and determine if preemption is allowed.  */
                            if (priority < execute_ptr -> tx_thread_preempt_threshold)
 810126c:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 810126e:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 8101270:	6dba      	ldr	r2, [r7, #88]	; 0x58
 8101272:	429a      	cmp	r2, r3
 8101274:	f080 8081 	bcs.w	810137a <_tx_thread_system_resume+0x202>
                            {

#ifndef TX_DISABLE_PREEMPTION_THRESHOLD

                                /* Determine if the preempted thread had preemption-threshold set.  */
                                if (execute_ptr -> tx_thread_preempt_threshold != execute_ptr -> tx_thread_priority)
 8101278:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 810127a:	6bda      	ldr	r2, [r3, #60]	; 0x3c
 810127c:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 810127e:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8101280:	429a      	cmp	r2, r3
 8101282:	d022      	beq.n	81012ca <_tx_thread_system_resume+0x152>
                                {

#if TX_MAX_PRIORITIES > 32

                                    /* Calculate the index into the bit map array.  */
                                    map_index =  (execute_ptr -> tx_thread_priority)/((UINT) 32);
 8101284:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 8101286:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8101288:	095b      	lsrs	r3, r3, #5
 810128a:	64fb      	str	r3, [r7, #76]	; 0x4c

                                    /* Set the active bit to remember that the preempt map has something set.  */
                                    TX_DIV32_BIT_SET(execute_ptr -> tx_thread_priority, priority_bit)
 810128c:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 810128e:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8101290:	095b      	lsrs	r3, r3, #5
 8101292:	2201      	movs	r2, #1
 8101294:	fa02 f303 	lsl.w	r3, r2, r3
 8101298:	64bb      	str	r3, [r7, #72]	; 0x48
                                    _tx_thread_preempted_map_active =  _tx_thread_preempted_map_active | priority_bit;
 810129a:	4b57      	ldr	r3, [pc, #348]	; (81013f8 <_tx_thread_system_resume+0x280>)
 810129c:	681a      	ldr	r2, [r3, #0]
 810129e:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 81012a0:	4313      	orrs	r3, r2
 81012a2:	4a55      	ldr	r2, [pc, #340]	; (81013f8 <_tx_thread_system_resume+0x280>)
 81012a4:	6013      	str	r3, [r2, #0]
#endif

                                    /* Remember that this thread was preempted by a thread above the thread's threshold.  */
                                    TX_MOD32_BIT_SET(execute_ptr -> tx_thread_priority, priority_bit)
 81012a6:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 81012a8:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 81012aa:	f003 031f 	and.w	r3, r3, #31
 81012ae:	2201      	movs	r2, #1
 81012b0:	fa02 f303 	lsl.w	r3, r2, r3
 81012b4:	64bb      	str	r3, [r7, #72]	; 0x48
                                    _tx_thread_preempted_maps[MAP_INDEX] =  _tx_thread_preempted_maps[MAP_INDEX] | priority_bit;
 81012b6:	4a51      	ldr	r2, [pc, #324]	; (81013fc <_tx_thread_system_resume+0x284>)
 81012b8:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 81012ba:	f852 2023 	ldr.w	r2, [r2, r3, lsl #2]
 81012be:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 81012c0:	431a      	orrs	r2, r3
 81012c2:	494e      	ldr	r1, [pc, #312]	; (81013fc <_tx_thread_system_resume+0x284>)
 81012c4:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 81012c6:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
                                execute_ptr -> tx_thread_performance_last_preempting_thread =  thread_ptr;

#endif

                                /* Yes, modify the execute thread pointer.  */
                                _tx_thread_execute_ptr =  thread_ptr;
 81012ca:	4a4a      	ldr	r2, [pc, #296]	; (81013f4 <_tx_thread_system_resume+0x27c>)
 81012cc:	687b      	ldr	r3, [r7, #4]
 81012ce:	6013      	str	r3, [r2, #0]
 81012d0:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
 81012d2:	633b      	str	r3, [r7, #48]	; 0x30
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 81012d4:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 81012d6:	f383 8810 	msr	PRIMASK, r3
}
 81012da:	bf00      	nop
                                TX_THREAD_STACK_CHECK(thread_ptr)
#endif

                                /* Now determine if preemption should take place. This is only possible if the current thread pointer is
                                   not the same as the execute thread pointer AND the system state and preempt disable flags are clear.  */
                                TX_THREAD_SYSTEM_RETURN_CHECK(combined_flags)
 81012dc:	4b40      	ldr	r3, [pc, #256]	; (81013e0 <_tx_thread_system_resume+0x268>)
 81012de:	681b      	ldr	r3, [r3, #0]
 81012e0:	643b      	str	r3, [r7, #64]	; 0x40
                                if (combined_flags == ((ULONG) 0))
 81012e2:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 81012e4:	2b00      	cmp	r3, #0
 81012e6:	d174      	bne.n	81013d2 <_tx_thread_system_resume+0x25a>
__attribute__( ( always_inline ) ) static inline void _tx_thread_system_return_inline(void)
{
unsigned int interrupt_save;

    /* Set PendSV to invoke ThreadX scheduler.  */
    *((volatile ULONG *) 0xE000ED04) = ((ULONG) 0x10000000);
 81012e8:	4b45      	ldr	r3, [pc, #276]	; (8101400 <_tx_thread_system_resume+0x288>)
 81012ea:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 81012ee:	601a      	str	r2, [r3, #0]
    __asm__ volatile (" MRS  %0,IPSR ": "=r" (ipsr_value) );
 81012f0:	f3ef 8305 	mrs	r3, IPSR
 81012f4:	62fb      	str	r3, [r7, #44]	; 0x2c
    return(ipsr_value);
 81012f6:	6afb      	ldr	r3, [r7, #44]	; 0x2c
    if (__get_ipsr_value() == 0)
 81012f8:	2b00      	cmp	r3, #0
 81012fa:	d10c      	bne.n	8101316 <_tx_thread_system_resume+0x19e>
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
 81012fc:	f3ef 8310 	mrs	r3, PRIMASK
 8101300:	62bb      	str	r3, [r7, #40]	; 0x28
    return(posture);
 8101302:	6abb      	ldr	r3, [r7, #40]	; 0x28
    {
        interrupt_save = __get_interrupt_posture();
 8101304:	627b      	str	r3, [r7, #36]	; 0x24
    __asm__ volatile ("CPSIE  i": : : "memory");
 8101306:	b662      	cpsie	i
}
 8101308:	bf00      	nop
 810130a:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 810130c:	623b      	str	r3, [r7, #32]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 810130e:	6a3b      	ldr	r3, [r7, #32]
 8101310:	f383 8810 	msr	PRIMASK, r3
}
 8101314:	bf00      	nop
#else
        __enable_interrupts();
#endif
        __restore_interrupt(interrupt_save);
    }
}
 8101316:	bf00      	nop
                                    /* Preemption is needed - return to the system!  */
                                    _tx_thread_system_return();
                                }

                                /* Return in-line when MISRA is not enabled.  */
                                return;
 8101318:	e05b      	b.n	81013d2 <_tx_thread_system_resume+0x25a>
                {

                    /* No, there are other threads at this priority already ready.  */

                    /* Just add this thread to the priority list.  */
                    tail_ptr =                                 head_ptr -> tx_thread_ready_previous;
 810131a:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 810131c:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 810131e:	653b      	str	r3, [r7, #80]	; 0x50
                    tail_ptr -> tx_thread_ready_next =         thread_ptr;
 8101320:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 8101322:	687a      	ldr	r2, [r7, #4]
 8101324:	621a      	str	r2, [r3, #32]
                    head_ptr -> tx_thread_ready_previous =     thread_ptr;
 8101326:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 8101328:	687a      	ldr	r2, [r7, #4]
 810132a:	625a      	str	r2, [r3, #36]	; 0x24
                    thread_ptr -> tx_thread_ready_previous =   tail_ptr;
 810132c:	687b      	ldr	r3, [r7, #4]
 810132e:	6d3a      	ldr	r2, [r7, #80]	; 0x50
 8101330:	625a      	str	r2, [r3, #36]	; 0x24
                    thread_ptr -> tx_thread_ready_next =       head_ptr;
 8101332:	687b      	ldr	r3, [r7, #4]
 8101334:	6d7a      	ldr	r2, [r7, #84]	; 0x54
 8101336:	621a      	str	r2, [r3, #32]
 8101338:	e01f      	b.n	810137a <_tx_thread_system_resume+0x202>
            /* Else, delayed suspend flag was set.  */
            else
            {

                /* Clear the delayed suspend flag and change the state.  */
                thread_ptr -> tx_thread_delayed_suspend =  TX_FALSE;
 810133a:	687b      	ldr	r3, [r7, #4]
 810133c:	2200      	movs	r2, #0
 810133e:	635a      	str	r2, [r3, #52]	; 0x34
                thread_ptr -> tx_thread_state =            TX_SUSPENDED;
 8101340:	687b      	ldr	r3, [r7, #4]
 8101342:	2203      	movs	r2, #3
 8101344:	631a      	str	r2, [r3, #48]	; 0x30
 8101346:	e018      	b.n	810137a <_tx_thread_system_resume+0x202>
        /* A resumption occurred in the middle of a previous thread suspension.  */

        /* Make sure the type of suspension under way is not a terminate or
           thread completion.  In either of these cases, do not void the
           interrupted suspension processing.  */
        if (thread_ptr -> tx_thread_state != TX_COMPLETED)
 8101348:	687b      	ldr	r3, [r7, #4]
 810134a:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 810134c:	2b01      	cmp	r3, #1
 810134e:	d014      	beq.n	810137a <_tx_thread_system_resume+0x202>
        {

            /* Make sure the thread isn't terminated.  */
            if (thread_ptr -> tx_thread_state != TX_TERMINATED)
 8101350:	687b      	ldr	r3, [r7, #4]
 8101352:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8101354:	2b02      	cmp	r3, #2
 8101356:	d010      	beq.n	810137a <_tx_thread_system_resume+0x202>
            {

                /* No, now check to see if the delayed suspension flag is set.  */
                if (thread_ptr -> tx_thread_delayed_suspend == TX_FALSE)
 8101358:	687b      	ldr	r3, [r7, #4]
 810135a:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 810135c:	2b00      	cmp	r3, #0
 810135e:	d106      	bne.n	810136e <_tx_thread_system_resume+0x1f6>
                {

                    /* Clear the suspending flag.  */
                    thread_ptr -> tx_thread_suspending =   TX_FALSE;
 8101360:	687b      	ldr	r3, [r7, #4]
 8101362:	2200      	movs	r2, #0
 8101364:	639a      	str	r2, [r3, #56]	; 0x38

                    /* Restore the state to ready.  */
                    thread_ptr -> tx_thread_state =        TX_READY;
 8101366:	687b      	ldr	r3, [r7, #4]
 8101368:	2200      	movs	r2, #0
 810136a:	631a      	str	r2, [r3, #48]	; 0x30
 810136c:	e005      	b.n	810137a <_tx_thread_system_resume+0x202>
                }
                else
                {

                    /* Clear the delayed suspend flag and change the state.  */
                    thread_ptr -> tx_thread_delayed_suspend =  TX_FALSE;
 810136e:	687b      	ldr	r3, [r7, #4]
 8101370:	2200      	movs	r2, #0
 8101372:	635a      	str	r2, [r3, #52]	; 0x34
                    thread_ptr -> tx_thread_state =            TX_SUSPENDED;
 8101374:	687b      	ldr	r3, [r7, #4]
 8101376:	2203      	movs	r2, #3
 8101378:	631a      	str	r2, [r3, #48]	; 0x30
        }
    }
#endif

    /* Pickup thread pointer.  */
    TX_THREAD_GET_CURRENT(current_thread)
 810137a:	4b22      	ldr	r3, [pc, #136]	; (8101404 <_tx_thread_system_resume+0x28c>)
 810137c:	681b      	ldr	r3, [r3, #0]
 810137e:	63fb      	str	r3, [r7, #60]	; 0x3c
 8101380:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
 8101382:	61fb      	str	r3, [r7, #28]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 8101384:	69fb      	ldr	r3, [r7, #28]
 8101386:	f383 8810 	msr	PRIMASK, r3
}
 810138a:	bf00      	nop

    /* Restore interrupts.  */
    TX_RESTORE

    /* Determine if a preemption condition is present.  */
    if (current_thread != _tx_thread_execute_ptr)
 810138c:	4b19      	ldr	r3, [pc, #100]	; (81013f4 <_tx_thread_system_resume+0x27c>)
 810138e:	681b      	ldr	r3, [r3, #0]
 8101390:	6bfa      	ldr	r2, [r7, #60]	; 0x3c
 8101392:	429a      	cmp	r2, r3
 8101394:	d020      	beq.n	81013d8 <_tx_thread_system_resume+0x260>
        TX_THREAD_STACK_CHECK(thread_ptr)
#endif

        /* Now determine if preemption should take place. This is only possible if the current thread pointer is
           not the same as the execute thread pointer AND the system state and preempt disable flags are clear.  */
        TX_THREAD_SYSTEM_RETURN_CHECK(combined_flags)
 8101396:	4b12      	ldr	r3, [pc, #72]	; (81013e0 <_tx_thread_system_resume+0x268>)
 8101398:	681b      	ldr	r3, [r3, #0]
 810139a:	643b      	str	r3, [r7, #64]	; 0x40
        if (combined_flags == ((ULONG) 0))
 810139c:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 810139e:	2b00      	cmp	r3, #0
 81013a0:	d11a      	bne.n	81013d8 <_tx_thread_system_resume+0x260>
    *((volatile ULONG *) 0xE000ED04) = ((ULONG) 0x10000000);
 81013a2:	4b17      	ldr	r3, [pc, #92]	; (8101400 <_tx_thread_system_resume+0x288>)
 81013a4:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 81013a8:	601a      	str	r2, [r3, #0]
    __asm__ volatile (" MRS  %0,IPSR ": "=r" (ipsr_value) );
 81013aa:	f3ef 8305 	mrs	r3, IPSR
 81013ae:	61bb      	str	r3, [r7, #24]
    return(ipsr_value);
 81013b0:	69bb      	ldr	r3, [r7, #24]
    if (__get_ipsr_value() == 0)
 81013b2:	2b00      	cmp	r3, #0
 81013b4:	d10f      	bne.n	81013d6 <_tx_thread_system_resume+0x25e>
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
 81013b6:	f3ef 8310 	mrs	r3, PRIMASK
 81013ba:	617b      	str	r3, [r7, #20]
    return(posture);
 81013bc:	697b      	ldr	r3, [r7, #20]
        interrupt_save = __get_interrupt_posture();
 81013be:	613b      	str	r3, [r7, #16]
    __asm__ volatile ("CPSIE  i": : : "memory");
 81013c0:	b662      	cpsie	i
}
 81013c2:	bf00      	nop
 81013c4:	693b      	ldr	r3, [r7, #16]
 81013c6:	60fb      	str	r3, [r7, #12]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 81013c8:	68fb      	ldr	r3, [r7, #12]
 81013ca:	f383 8810 	msr	PRIMASK, r3
}
 81013ce:	bf00      	nop
}
 81013d0:	e001      	b.n	81013d6 <_tx_thread_system_resume+0x25e>
                                return;
 81013d2:	bf00      	nop
 81013d4:	e000      	b.n	81013d8 <_tx_thread_system_resume+0x260>
 81013d6:	bf00      	nop

            /* Preemption is needed - return to the system!  */
            _tx_thread_system_return();
        }
    }
}
 81013d8:	3760      	adds	r7, #96	; 0x60
 81013da:	46bd      	mov	sp, r7
 81013dc:	bd80      	pop	{r7, pc}
 81013de:	bf00      	nop
 81013e0:	10000154 	.word	0x10000154
 81013e4:	10000054 	.word	0x10000054
 81013e8:	10000040 	.word	0x10000040
 81013ec:	10000038 	.word	0x10000038
 81013f0:	10000050 	.word	0x10000050
 81013f4:	10000034 	.word	0x10000034
 81013f8:	1000004c 	.word	0x1000004c
 81013fc:	10000044 	.word	0x10000044
 8101400:	e000ed04 	.word	0xe000ed04
 8101404:	10000030 	.word	0x10000030

08101408 <_tx_thread_time_slice>:
/*                                            TX_NO_TIMER is defined,     */
/*                                            resulting in version 6.1    */
/*                                                                        */
/**************************************************************************/
VOID  _tx_thread_time_slice(VOID)
{
 8101408:	b480      	push	{r7}
 810140a:	b087      	sub	sp, #28
 810140c:	af00      	add	r7, sp, #0
ULONG           system_state;
UINT            preempt_disable;
#endif

    /* Pickup thread pointer.  */
    TX_THREAD_GET_CURRENT(thread_ptr)
 810140e:	4b21      	ldr	r3, [pc, #132]	; (8101494 <_tx_thread_time_slice+0x8c>)
 8101410:	681b      	ldr	r3, [r3, #0]
 8101412:	617b      	str	r3, [r7, #20]
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
 8101414:	f3ef 8310 	mrs	r3, PRIMASK
 8101418:	60fb      	str	r3, [r7, #12]
    return(posture);
 810141a:	68fb      	ldr	r3, [r7, #12]
    int_posture = __get_interrupt_posture();
 810141c:	60bb      	str	r3, [r7, #8]
    __asm__ volatile ("CPSID i" : : : "memory");
 810141e:	b672      	cpsid	i
    return(int_posture);
 8101420:	68bb      	ldr	r3, [r7, #8]
    /* Set the next thread pointer to NULL.  */
    next_thread_ptr =  TX_NULL;
#endif

    /* Lockout interrupts while the time-slice is evaluated.  */
    TX_DISABLE
 8101422:	613b      	str	r3, [r7, #16]

    /* Clear the expired time-slice flag.  */
    _tx_timer_expired_time_slice =  TX_FALSE;
 8101424:	4b1c      	ldr	r3, [pc, #112]	; (8101498 <_tx_thread_time_slice+0x90>)
 8101426:	2200      	movs	r2, #0
 8101428:	601a      	str	r2, [r3, #0]

    /* Make sure the thread pointer is valid.  */
    if (thread_ptr != TX_NULL)
 810142a:	697b      	ldr	r3, [r7, #20]
 810142c:	2b00      	cmp	r3, #0
 810142e:	d024      	beq.n	810147a <_tx_thread_time_slice+0x72>
    {

        /* Make sure the thread is still active, i.e. not suspended.  */
        if (thread_ptr -> tx_thread_state == TX_READY)
 8101430:	697b      	ldr	r3, [r7, #20]
 8101432:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8101434:	2b00      	cmp	r3, #0
 8101436:	d120      	bne.n	810147a <_tx_thread_time_slice+0x72>
        {

            /* Setup a fresh time-slice for the thread.  */
            thread_ptr -> tx_thread_time_slice =  thread_ptr -> tx_thread_new_time_slice;
 8101438:	697b      	ldr	r3, [r7, #20]
 810143a:	69da      	ldr	r2, [r3, #28]
 810143c:	697b      	ldr	r3, [r7, #20]
 810143e:	619a      	str	r2, [r3, #24]

            /* Reset the actual time-slice variable.  */
            _tx_timer_time_slice =  thread_ptr -> tx_thread_time_slice;
 8101440:	697b      	ldr	r3, [r7, #20]
 8101442:	699b      	ldr	r3, [r3, #24]
 8101444:	4a15      	ldr	r2, [pc, #84]	; (810149c <_tx_thread_time_slice+0x94>)
 8101446:	6013      	str	r3, [r2, #0]

            /* Determine if there is another thread at the same priority and preemption-threshold
               is not set.  Preemption-threshold overrides time-slicing.  */
            if (thread_ptr -> tx_thread_ready_next != thread_ptr)
 8101448:	697b      	ldr	r3, [r7, #20]
 810144a:	6a1b      	ldr	r3, [r3, #32]
 810144c:	697a      	ldr	r2, [r7, #20]
 810144e:	429a      	cmp	r2, r3
 8101450:	d013      	beq.n	810147a <_tx_thread_time_slice+0x72>
            {

                /* Check to see if preemption-threshold is not being used.  */
                if (thread_ptr -> tx_thread_priority == thread_ptr -> tx_thread_preempt_threshold)
 8101452:	697b      	ldr	r3, [r7, #20]
 8101454:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 8101456:	697b      	ldr	r3, [r7, #20]
 8101458:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 810145a:	429a      	cmp	r2, r3
 810145c:	d10d      	bne.n	810147a <_tx_thread_time_slice+0x72>

                    /* Preemption-threshold is not being used by this thread.  */

                    /* There is another thread at this priority, make it the highest at
                       this priority level.  */
                    _tx_thread_priority_list[thread_ptr -> tx_thread_priority] =  thread_ptr -> tx_thread_ready_next;
 810145e:	697b      	ldr	r3, [r7, #20]
 8101460:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8101462:	697a      	ldr	r2, [r7, #20]
 8101464:	6a12      	ldr	r2, [r2, #32]
 8101466:	490e      	ldr	r1, [pc, #56]	; (81014a0 <_tx_thread_time_slice+0x98>)
 8101468:	f841 2023 	str.w	r2, [r1, r3, lsl #2]

                    /* Designate the highest priority thread as the one to execute.  Don't use this
                       thread's priority as an index just in case a higher priority thread is now
                       ready!  */
                    _tx_thread_execute_ptr =  _tx_thread_priority_list[_tx_thread_highest_priority];
 810146c:	4b0d      	ldr	r3, [pc, #52]	; (81014a4 <_tx_thread_time_slice+0x9c>)
 810146e:	681b      	ldr	r3, [r3, #0]
 8101470:	4a0b      	ldr	r2, [pc, #44]	; (81014a0 <_tx_thread_time_slice+0x98>)
 8101472:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 8101476:	4a0c      	ldr	r2, [pc, #48]	; (81014a8 <_tx_thread_time_slice+0xa0>)
 8101478:	6013      	str	r3, [r2, #0]
 810147a:	693b      	ldr	r3, [r7, #16]
 810147c:	607b      	str	r3, [r7, #4]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 810147e:	687b      	ldr	r3, [r7, #4]
 8101480:	f383 8810 	msr	PRIMASK, r3
}
 8101484:	bf00      	nop

        /* Yes, check this thread's stack.  */
        TX_THREAD_STACK_CHECK(next_thread_ptr)
    }
#endif
}
 8101486:	bf00      	nop
 8101488:	371c      	adds	r7, #28
 810148a:	46bd      	mov	sp, r7
 810148c:	f85d 7b04 	ldr.w	r7, [sp], #4
 8101490:	4770      	bx	lr
 8101492:	bf00      	nop
 8101494:	10000030 	.word	0x10000030
 8101498:	1000015c 	.word	0x1000015c
 810149c:	10000224 	.word	0x10000224
 81014a0:	10000054 	.word	0x10000054
 81014a4:	10000050 	.word	0x10000050
 81014a8:	10000034 	.word	0x10000034

081014ac <_tx_timer_expiration_process>:
/*                                            TX_NO_TIMER is defined,     */
/*                                            resulting in version 6.1    */
/*                                                                        */
/**************************************************************************/
VOID  _tx_timer_expiration_process(VOID)
{
 81014ac:	b580      	push	{r7, lr}
 81014ae:	b084      	sub	sp, #16
 81014b0:	af00      	add	r7, sp, #0
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
 81014b2:	f3ef 8310 	mrs	r3, PRIMASK
 81014b6:	607b      	str	r3, [r7, #4]
    return(posture);
 81014b8:	687b      	ldr	r3, [r7, #4]
    int_posture = __get_interrupt_posture();
 81014ba:	603b      	str	r3, [r7, #0]
    __asm__ volatile ("CPSID i" : : : "memory");
 81014bc:	b672      	cpsid	i
    return(int_posture);
 81014be:	683b      	ldr	r3, [r7, #0]

    /* Don't process in the ISR, wakeup the system timer thread to process the
       timer expiration.  */

    /* Disable interrupts.  */
    TX_DISABLE
 81014c0:	60fb      	str	r3, [r7, #12]
    /* Restore interrupts.  */
    TX_RESTORE
#else

    /* Increment the preempt disable flag.  */
    _tx_thread_preempt_disable++;
 81014c2:	4b09      	ldr	r3, [pc, #36]	; (81014e8 <_tx_timer_expiration_process+0x3c>)
 81014c4:	681b      	ldr	r3, [r3, #0]
 81014c6:	3301      	adds	r3, #1
 81014c8:	4a07      	ldr	r2, [pc, #28]	; (81014e8 <_tx_timer_expiration_process+0x3c>)
 81014ca:	6013      	str	r3, [r2, #0]
 81014cc:	68fb      	ldr	r3, [r7, #12]
 81014ce:	60bb      	str	r3, [r7, #8]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 81014d0:	68bb      	ldr	r3, [r7, #8]
 81014d2:	f383 8810 	msr	PRIMASK, r3
}
 81014d6:	bf00      	nop

    /* Restore interrupts.  */
    TX_RESTORE

    /* Call the system resume function to activate the timer thread.  */
    _tx_thread_system_resume(&_tx_timer_thread);
 81014d8:	4804      	ldr	r0, [pc, #16]	; (81014ec <_tx_timer_expiration_process+0x40>)
 81014da:	f7ff fe4d 	bl	8101178 <_tx_thread_system_resume>
    }

    /* Restore interrupts.  */
    TX_RESTORE
#endif
}
 81014de:	bf00      	nop
 81014e0:	3710      	adds	r7, #16
 81014e2:	46bd      	mov	sp, r7
 81014e4:	bd80      	pop	{r7, pc}
 81014e6:	bf00      	nop
 81014e8:	10000154 	.word	0x10000154
 81014ec:	10000170 	.word	0x10000170

081014f0 <_tx_timer_system_deactivate>:
/*  09-30-2020     Yuxin Zhou               Modified comment(s),          */
/*                                            resulting in version 6.1    */
/*                                                                        */
/**************************************************************************/
VOID  _tx_timer_system_deactivate(TX_TIMER_INTERNAL *timer_ptr)
{
 81014f0:	b480      	push	{r7}
 81014f2:	b087      	sub	sp, #28
 81014f4:	af00      	add	r7, sp, #0
 81014f6:	6078      	str	r0, [r7, #4]
TX_TIMER_INTERNAL   *next_timer;
TX_TIMER_INTERNAL   *previous_timer;


    /* Pickup the list head pointer.  */
    list_head =  timer_ptr -> tx_timer_internal_list_head;
 81014f8:	687b      	ldr	r3, [r7, #4]
 81014fa:	699b      	ldr	r3, [r3, #24]
 81014fc:	617b      	str	r3, [r7, #20]

    /* Determine if the timer still needs deactivation.  */
    if (list_head != TX_NULL)
 81014fe:	697b      	ldr	r3, [r7, #20]
 8101500:	2b00      	cmp	r3, #0
 8101502:	d026      	beq.n	8101552 <_tx_timer_system_deactivate+0x62>
    {

        /* Deactivate the timer.  */

        /* Pickup the next active timer.  */
        next_timer =  timer_ptr -> tx_timer_internal_active_next;
 8101504:	687b      	ldr	r3, [r7, #4]
 8101506:	691b      	ldr	r3, [r3, #16]
 8101508:	613b      	str	r3, [r7, #16]

        /* See if this is the only timer in the list.  */
        if (timer_ptr == next_timer)
 810150a:	687a      	ldr	r2, [r7, #4]
 810150c:	693b      	ldr	r3, [r7, #16]
 810150e:	429a      	cmp	r2, r3
 8101510:	d108      	bne.n	8101524 <_tx_timer_system_deactivate+0x34>
        {

            /* Yes, the only timer on the list.  */

            /* Determine if the head pointer needs to be updated.  */
            if (*(list_head) == timer_ptr)
 8101512:	697b      	ldr	r3, [r7, #20]
 8101514:	681b      	ldr	r3, [r3, #0]
 8101516:	687a      	ldr	r2, [r7, #4]
 8101518:	429a      	cmp	r2, r3
 810151a:	d117      	bne.n	810154c <_tx_timer_system_deactivate+0x5c>
            {

                /* Update the head pointer.  */
                *(list_head) =  TX_NULL;
 810151c:	697b      	ldr	r3, [r7, #20]
 810151e:	2200      	movs	r2, #0
 8101520:	601a      	str	r2, [r3, #0]
 8101522:	e013      	b.n	810154c <_tx_timer_system_deactivate+0x5c>
        {

            /* At least one more timer is on the same expiration list.  */

            /* Update the links of the adjacent timers.  */
            previous_timer =                                   timer_ptr -> tx_timer_internal_active_previous;
 8101524:	687b      	ldr	r3, [r7, #4]
 8101526:	695b      	ldr	r3, [r3, #20]
 8101528:	60fb      	str	r3, [r7, #12]
            next_timer -> tx_timer_internal_active_previous =  previous_timer;
 810152a:	693b      	ldr	r3, [r7, #16]
 810152c:	68fa      	ldr	r2, [r7, #12]
 810152e:	615a      	str	r2, [r3, #20]
            previous_timer -> tx_timer_internal_active_next =  next_timer;
 8101530:	68fb      	ldr	r3, [r7, #12]
 8101532:	693a      	ldr	r2, [r7, #16]
 8101534:	611a      	str	r2, [r3, #16]

            /* Determine if the head pointer needs to be updated.  */
            if (*(list_head) == timer_ptr)
 8101536:	697b      	ldr	r3, [r7, #20]
 8101538:	681b      	ldr	r3, [r3, #0]
 810153a:	687a      	ldr	r2, [r7, #4]
 810153c:	429a      	cmp	r2, r3
 810153e:	d105      	bne.n	810154c <_tx_timer_system_deactivate+0x5c>
            {

                /* Update the next timer in the list with the list head pointer.  */
                next_timer -> tx_timer_internal_list_head =  list_head;
 8101540:	693b      	ldr	r3, [r7, #16]
 8101542:	697a      	ldr	r2, [r7, #20]
 8101544:	619a      	str	r2, [r3, #24]

                /* Update the head pointer.  */
                *(list_head) =  next_timer;
 8101546:	697b      	ldr	r3, [r7, #20]
 8101548:	693a      	ldr	r2, [r7, #16]
 810154a:	601a      	str	r2, [r3, #0]
            }
        }

        /* Clear the timer's list head pointer.  */
        timer_ptr -> tx_timer_internal_list_head =  TX_NULL;
 810154c:	687b      	ldr	r3, [r7, #4]
 810154e:	2200      	movs	r2, #0
 8101550:	619a      	str	r2, [r3, #24]
    }
}
 8101552:	bf00      	nop
 8101554:	371c      	adds	r7, #28
 8101556:	46bd      	mov	sp, r7
 8101558:	f85d 7b04 	ldr.w	r7, [sp], #4
 810155c:	4770      	bx	lr
	...

08101560 <__libc_init_array>:
 8101560:	b570      	push	{r4, r5, r6, lr}
 8101562:	4d0d      	ldr	r5, [pc, #52]	; (8101598 <__libc_init_array+0x38>)
 8101564:	4c0d      	ldr	r4, [pc, #52]	; (810159c <__libc_init_array+0x3c>)
 8101566:	1b64      	subs	r4, r4, r5
 8101568:	10a4      	asrs	r4, r4, #2
 810156a:	2600      	movs	r6, #0
 810156c:	42a6      	cmp	r6, r4
 810156e:	d109      	bne.n	8101584 <__libc_init_array+0x24>
 8101570:	4d0b      	ldr	r5, [pc, #44]	; (81015a0 <__libc_init_array+0x40>)
 8101572:	4c0c      	ldr	r4, [pc, #48]	; (81015a4 <__libc_init_array+0x44>)
 8101574:	f000 f818 	bl	81015a8 <_init>
 8101578:	1b64      	subs	r4, r4, r5
 810157a:	10a4      	asrs	r4, r4, #2
 810157c:	2600      	movs	r6, #0
 810157e:	42a6      	cmp	r6, r4
 8101580:	d105      	bne.n	810158e <__libc_init_array+0x2e>
 8101582:	bd70      	pop	{r4, r5, r6, pc}
 8101584:	f855 3b04 	ldr.w	r3, [r5], #4
 8101588:	4798      	blx	r3
 810158a:	3601      	adds	r6, #1
 810158c:	e7ee      	b.n	810156c <__libc_init_array+0xc>
 810158e:	f855 3b04 	ldr.w	r3, [r5], #4
 8101592:	4798      	blx	r3
 8101594:	3601      	adds	r6, #1
 8101596:	e7f2      	b.n	810157e <__libc_init_array+0x1e>
 8101598:	081015d0 	.word	0x081015d0
 810159c:	081015d0 	.word	0x081015d0
 81015a0:	081015d0 	.word	0x081015d0
 81015a4:	081015d4 	.word	0x081015d4

081015a8 <_init>:
 81015a8:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 81015aa:	bf00      	nop
 81015ac:	bcf8      	pop	{r3, r4, r5, r6, r7}
 81015ae:	bc08      	pop	{r3}
 81015b0:	469e      	mov	lr, r3
 81015b2:	4770      	bx	lr

081015b4 <_fini>:
 81015b4:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 81015b6:	bf00      	nop
 81015b8:	bcf8      	pop	{r3, r4, r5, r6, r7}
 81015ba:	bc08      	pop	{r3}
 81015bc:	469e      	mov	lr, r3
 81015be:	4770      	bx	lr
